{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"fluxopt","text":"<p>Energy system optimization with linopy \u2014 progressive modeling, from simple to complex.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install fluxopt\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p>A gas boiler covers a heat demand, minimizing fuel cost:</p> <pre><code>from datetime import datetime\nfrom fluxopt import Bus, Converter, Effect, Flow, Port, optimize\n\ntimesteps = [datetime(2024, 1, 1, h) for h in range(4)]\n\n# Flows\ngas_source = Flow(bus='gas', size=500, effects_per_flow_hour={'cost': 0.04})\nfuel = Flow(bus='gas', size=300)\nheat = Flow(bus='heat', size=200)\ndemand = Flow(bus='heat', size=100, fixed_relative_profile=[0.4, 0.7, 0.5, 0.6])\n\nresult = optimize(\n    timesteps=timesteps,\n    buses=[Bus('gas'), Bus('heat')],\n    effects=[Effect('cost', is_objective=True)],\n    ports=[Port('grid', imports=[gas_source]), Port('demand', exports=[demand])],\n    converters=[Converter.boiler('boiler', thermal_efficiency=0.9, fuel_flow=fuel, thermal_flow=heat)],\n)\n\nprint(f\"Total cost: {result.objective:.2f}\")\nprint(result.flow_rates)\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Guide \u2014 walkthrough of the full API, from flows to storage</li> <li>Math \u2014 formulation reference with notation, constraints, and examples</li> </ul>"},{"location":"guide/converters/","title":"Converters","text":"<p>A <code>Converter</code> enforces linear coupling between input and output flows. It models devices like boilers, heat pumps, and CHP plants.</p> <p>See Converters (Math) for the formulation.</p>"},{"location":"guide/converters/#factory-methods","title":"Factory Methods","text":""},{"location":"guide/converters/#boiler","title":"Boiler","text":"<p>Single input (fuel), single output (heat), with thermal efficiency:</p> <pre><code>from fluxopt import Converter, Flow\n\nfuel = Flow(bus='gas', size=300)\nheat = Flow(bus='heat', size=200)\n\nboiler = Converter.boiler('boiler', thermal_efficiency=0.9, fuel_flow=fuel, thermal_flow=heat)\n</code></pre> <p>This creates the conversion equation: <code>0.9 * P_gas - P_heat = 0</code>, so 10 MW gas input produces 9 MW heat.</p>"},{"location":"guide/converters/#power-to-heat","title":"Power-to-Heat","text":"<p>Electric resistance heater \u2014 single input (electricity), single output (heat):</p> <pre><code>el = Flow(bus='elec', size=50)\nth = Flow(bus='heat', size=50)\n\np2h = Converter.power2heat('p2h', efficiency=0.99, electrical_flow=el, thermal_flow=th)\n</code></pre> <p>Conversion equation: <code>0.99 * P_el - P_heat = 0</code>.</p>"},{"location":"guide/converters/#heat-pump","title":"Heat Pump","text":"<p>Two inputs (electricity + environmental source), single output (heat), with COP:</p> <pre><code>el = Flow(bus='elec', size=50)\nsrc = Flow(bus='env', size=200)\nth = Flow(bus='heat', size=200)\n\nhp = Converter.heat_pump('hp', cop=3.5, electrical_flow=el, source_flow=src, thermal_flow=th)\n</code></pre> <p>Two conversion equations:</p> <ul> <li><code>3.5 * P_el - P_heat = 0</code> (COP definition)</li> <li><code>P_el + P_env - P_heat = 0</code> (energy balance)</li> </ul>"},{"location":"guide/converters/#chp-combined-heat-and-power","title":"CHP (Combined Heat and Power)","text":"<p>Single input (fuel), two outputs (electricity + heat). Two conversion equations, one per output:</p> <pre><code>fuel = Flow(bus='gas', size=100)\nel = Flow(bus='elec', size=50)\nth = Flow(bus='heat', size=60)\n\nchp = Converter.chp('chp', eta_el=0.4, eta_th=0.5,\n                     fuel_flow=fuel, electrical_flow=el, thermal_flow=th)\n</code></pre> <p>This produces two equations:</p> <ul> <li><code>0.4 * P_fuel - P_el = 0</code></li> <li><code>0.5 * P_fuel - P_heat = 0</code></li> </ul> <p>So 10 MW fuel input produces 4 MW electrical + 5 MW thermal.</p>"},{"location":"guide/converters/#custom-conversion-factors","title":"Custom Conversion Factors","text":"<p>For devices not covered by factory methods, pass <code>conversion_factors</code> directly. Each dict in the list is one conversion equation, mapping flows to their coefficients:</p> <pre><code>in1 = Flow(bus='a', size=100)\nin2 = Flow(bus='b', size=100)\nout = Flow(bus='c', size=100)\n\nconv = Converter(\n    id='custom',\n    inputs=[in1, in2],\n    outputs=[out],\n    conversion_factors=[{in1: 0.5, in2: 0.3, out: -1}],\n)\n</code></pre> <p>This enforces: <code>0.5 * P_a + 0.3 * P_b - P_c = 0</code>.</p>"},{"location":"guide/converters/#time-varying-coefficients","title":"Time-Varying Coefficients","text":"<p>Coefficients can vary per timestep (e.g., a heat pump with weather-dependent COP):</p> <pre><code>cop_profile = [3.2, 3.5, 3.8, 3.1]  # one value per timestep\nhp = Converter.heat_pump('hp', cop=cop_profile, electrical_flow=el, source_flow=src, thermal_flow=th)\n</code></pre>"},{"location":"guide/converters/#full-example","title":"Full Example","text":"<p>Gas boiler serving a heat demand:</p> <pre><code>from datetime import datetime\nfrom fluxopt import Bus, Converter, Effect, Flow, Port, optimize\n\ntimesteps = [datetime(2024, 1, 1, h) for h in range(4)]\ndemand = [40.0, 70.0, 50.0, 60.0]\n\ngas_source = Flow(bus='gas', size=500, effects_per_flow_hour={'cost': 0.04})\nfuel = Flow(bus='gas', size=300)\nheat = Flow(bus='heat', size=200)\ndemand_flow = Flow(bus='heat', size=100, fixed_relative_profile=[0.4, 0.7, 0.5, 0.6])\n\nresult = optimize(\n    timesteps=timesteps,\n    buses=[Bus('gas'), Bus('heat')],\n    effects=[Effect('cost', is_objective=True)],\n    ports=[Port('grid', imports=[gas_source]), Port('demand', exports=[demand_flow])],\n    converters=[Converter.boiler('boiler', thermal_efficiency=0.9, fuel_flow=fuel, thermal_flow=heat)],\n)\n\n# Gas consumed = heat / efficiency\nprint(result.flow_rate('boiler(gas)'))\n</code></pre>"},{"location":"guide/effects/","title":"Effects","text":"<p>An <code>Effect</code> tracks a quantity (cost, CO2, primary energy, ...) across the optimization horizon. One effect is the objective to minimize; others can be bounded.</p> <p>See Effects (Math) for the formulation.</p>"},{"location":"guide/effects/#defining-effects","title":"Defining Effects","text":"<pre><code>from fluxopt import Effect\n\n# Objective effect (minimized)\ncost = Effect('cost', is_objective=True)\n\n# Tracked effect with a unit\nco2 = Effect('co2', unit='kg')\n</code></pre> <p>Exactly one effect must have <code>is_objective=True</code>.</p>"},{"location":"guide/effects/#linking-flows-to-effects","title":"Linking Flows to Effects","text":"<p>Flows contribute to effects via <code>effects_per_flow_hour</code>. The value is in effect-units per flow-hour (e.g., \u20ac/MWh):</p> <pre><code>from fluxopt import Flow\n\n# Single effect\ngas = Flow(bus='gas', size=500, effects_per_flow_hour={'cost': 0.04})\n\n# Multiple effects\ngas = Flow(bus='gas', size=500, effects_per_flow_hour={'cost': 0.04, 'co2': 0.2})\n</code></pre> <p>At each timestep, the contribution is <code>coefficient * flow_rate * dt</code>.</p>"},{"location":"guide/effects/#bounding-effects","title":"Bounding Effects","text":""},{"location":"guide/effects/#total-bounds","title":"Total Bounds","text":"<p>Limit the total effect over the entire horizon:</p> <pre><code># CO2 budget: max 1000 kg total\nco2 = Effect('co2', unit='kg', maximum_total=1000)\n\n# Cost floor (e.g., minimum revenue)\nrevenue = Effect('revenue', minimum_total=500)\n</code></pre>"},{"location":"guide/effects/#per-hour-bounds","title":"Per-Hour Bounds","text":"<p>Limit the effect value at each timestep:</p> <pre><code># Max 50 kg CO2 per hour\nco2 = Effect('co2', unit='kg', maximum_per_hour=50)\n\n# Time-varying per-hour bound\nco2 = Effect('co2', unit='kg', maximum_per_hour=[50, 40, 60, 50])\n</code></pre>"},{"location":"guide/effects/#cross-effect-contributions","title":"Cross-Effect Contributions","text":"<p>An effect can include a weighted contribution from another effect using <code>contribution_from</code>. This is useful for carbon pricing, primary energy factors, or any chain where one tracked quantity feeds into another.</p>"},{"location":"guide/effects/#scalar-temporal-periodic","title":"Scalar (temporal + periodic)","text":"<p>A scalar factor applies to both domains \u2014 temporal (per-timestep) and periodic (sizing, yearly costs):</p> <pre><code>effects = [\n    Effect('cost', is_objective=True, contribution_from={'co2': 50}),\n    Effect('co2', unit='kg'),\n]\n</code></pre> <p>Here, every kg of CO\u2082 adds 50 \u20ac to cost \u2014 both for temporal emissions (from flow operation) and periodic emissions (e.g., from <code>Sizing.effects_per_size</code>).</p>"},{"location":"guide/effects/#time-varying-temporal-only","title":"Time-Varying (temporal only)","text":"<p>Use <code>contribution_from_per_hour</code> for time-varying factors that override the scalar in the temporal domain:</p> <pre><code>effects = [\n    Effect(\n        'cost',\n        is_objective=True,\n        contribution_from={'co2': 50},  # scalar for periodic domain\n        contribution_from_per_hour={'co2': [40, 50, 60]},  # time-varying for temporal domain\n    ),\n    Effect('co2', unit='kg'),\n]\n</code></pre>"},{"location":"guide/effects/#transitive-chains","title":"Transitive Chains","text":"<p>Contributions chain transitively. A PE \u2192 CO\u2082 \u2192 cost chain is modeled as:</p> <pre><code>effects = [\n    Effect('cost', is_objective=True, contribution_from={'co2': 50}),\n    Effect('co2', unit='kg', contribution_from={'pe': 0.3}),\n    Effect('pe', unit='kWh'),\n]\n</code></pre>"},{"location":"guide/effects/#restrictions","title":"Restrictions","text":"<ul> <li>No self-references: an effect cannot reference itself</li> <li>No cycles: <code>cost \u2192 co2 \u2192 cost</code> is rejected at build time</li> </ul> <p>See Effects (Math) for the formulation.</p>"},{"location":"guide/effects/#accessing-results","title":"Accessing Results","text":"<p>After solving, the <code>Result</code> provides several views into effect values:</p> <pre><code>result = optimize(...)\n\n# Objective value (shortcut for the objective effect's total)\nprint(result.objective)\n\n# Total effect values as (effect,) DataArray\nprint(result.effect_totals)\n\n# Temporal: per-timestep effect values as (effect, time) DataArray\nprint(result.effects_temporal)\n\n# Periodic: sizing and fixed-cost effect values as (effect,) DataArray\nprint(result.effects_periodic)\n</code></pre>"},{"location":"guide/effects/#per-contributor-breakdown","title":"Per-Contributor Breakdown","text":"<p><code>effect_contributions()</code> decomposes effect totals into per-contributor parts on a unified <code>contributor</code> dimension (flow IDs + storage IDs), matching the model's temporal/periodic domain structure:</p> <pre><code>contrib = result.effect_contributions()\n\n# Per-timestep contributions (contributor, effect, time) \u2014 flows only\ncontrib['temporal']\n\n# Periodic contributions (contributor, effect) \u2014 flows + storages\ncontrib['periodic']\n\n# Total per contributor: temporal summed over time + periodic (contributor, effect)\ncontrib['total']\n</code></pre> <p>The contributions are validated against the solver totals \u2014 if they don't sum to <code>effect_totals</code>, a <code>ValueError</code> is raised.</p> <p>Cross-effects (e.g., CO\u2082 \u2192 cost) are attributed to the originating contributor. If a gas flow emits CO\u2082 priced at 50 \u20ac/kg, its cost contribution includes both the direct cost and the carbon tax portion.</p>"},{"location":"guide/effects/#full-example","title":"Full Example","text":"<p>Two sources with different cost/CO2 tradeoffs, subject to an emission cap:</p> <pre><code>from datetime import datetime\nfrom fluxopt import Bus, Effect, Flow, Port, optimize\n\ntimesteps = [datetime(2024, 1, 1, h) for h in range(3)]\n\ndemand = Flow(bus='elec', size=100, fixed_relative_profile=[0.5, 0.8, 0.6])\ncheap_dirty = Flow(bus='elec', size=200, effects_per_flow_hour={'cost': 0.02, 'co2': 1.0})\nexpensive_clean = Flow(bus='elec', size=200, effects_per_flow_hour={'cost': 0.10, 'co2': 0.0})\n\nresult = optimize(\n    timesteps=timesteps,\n    buses=[Bus('elec')],\n    effects=[\n        Effect('cost', is_objective=True),\n        Effect('co2', maximum_total=100),\n    ],\n    ports=[\n        Port('cheap', imports=[cheap_dirty]),\n        Port('clean', imports=[expensive_clean]),\n        Port('demand', exports=[demand]),\n    ],\n)\n\nprint(f\"Total cost: {result.objective:.2f}\")\nprint(result.effect_totals)\n</code></pre>"},{"location":"guide/effects/#parameters-summary","title":"Parameters Summary","text":"Parameter Type Default Description <code>id</code> <code>str</code> required Effect identifier <code>unit</code> <code>str</code> <code>''</code> Unit label <code>is_objective</code> <code>bool</code> <code>False</code> Whether this effect is minimized <code>maximum_total</code> <code>float \\| None</code> <code>None</code> Upper bound on total <code>minimum_total</code> <code>float \\| None</code> <code>None</code> Lower bound on total <code>maximum_per_hour</code> <code>TimeSeries \\| None</code> <code>None</code> Upper bound per timestep <code>minimum_per_hour</code> <code>TimeSeries \\| None</code> <code>None</code> Lower bound per timestep <code>contribution_from</code> <code>dict[str, float]</code> <code>{}</code> Cross-effect factor (both domains) <code>contribution_from_per_hour</code> <code>dict[str, TimeSeries]</code> <code>{}</code> Cross-effect factor (temporal domain only)"},{"location":"guide/flows/","title":"Flows","text":"<p>A <code>Flow</code> represents energy transfer on a bus. Flows are the building blocks \u2014 every port, converter, and storage is defined through its flows.</p> <p>See Flows (Math) for the formulation.</p>"},{"location":"guide/flows/#basic-construction","title":"Basic Construction","text":"<pre><code>from fluxopt import Flow\n\n# Minimal: just a bus\nf = Flow(bus='heat')\n\n# With capacity\nf = Flow(bus='heat', size=100)  # 100 MW nominal capacity\n</code></pre>"},{"location":"guide/flows/#sizing","title":"Sizing","text":"<p><code>size</code> sets the nominal capacity \\(\\bar{P}_f\\) in MW. When set, all relative parameters are scaled by this value:</p> <pre><code># Sized: flow rate bounded to [0, 100] MW\nf = Flow(bus='heat', size=100)\n\n# Unsized: flow rate bounded to [0, \u221e)\nf = Flow(bus='heat')\n</code></pre>"},{"location":"guide/flows/#bounds","title":"Bounds","text":"<p><code>relative_minimum</code> and <code>relative_maximum</code> set per-timestep bounds as fractions of <code>size</code>:</p> <pre><code># Minimum load 30%, maximum 100% \u2192 [30, 100] MW\nf = Flow(bus='heat', size=100, relative_minimum=0.3)\n\n# Time-varying maximum\nf = Flow(bus='heat', size=100, relative_maximum=[1.0, 0.8, 0.6, 1.0])\n</code></pre>"},{"location":"guide/flows/#fixed-profiles","title":"Fixed Profiles","text":"<p><code>fixed_relative_profile</code> pins the flow to an exact profile scaled by <code>size</code>:</p> <pre><code># Demand: 40, 70, 50, 60 MW\nf = Flow(bus='heat', size=100, fixed_relative_profile=[0.4, 0.7, 0.5, 0.6])\n</code></pre> <p>This sets both lower and upper bounds equal to the profile value.</p>"},{"location":"guide/flows/#effect-coefficients","title":"Effect Coefficients","text":"<p><code>effects_per_flow_hour</code> assigns cost or emission coefficients to a flow. Values are in units per flow-hour (e.g., \u20ac/MWh):</p> <pre><code># Constant cost\nf = Flow(bus='gas', size=500, effects_per_flow_hour={'cost': 0.04})\n\n# Multiple effects\nf = Flow(bus='gas', size=500, effects_per_flow_hour={'cost': 0.04, 'co2': 0.2})\n\n# Time-varying cost\nf = Flow(bus='gas', size=500, effects_per_flow_hour={'cost': [0.02, 0.08, 0.04]})\n</code></pre> <p>See Effects for how these coefficients feed into the objective and constraints.</p>"},{"location":"guide/flows/#id-qualification","title":"Id Qualification","text":"<p>Flow ids are auto-qualified by the parent component. You rarely need to set <code>id</code> explicitly:</p> <pre><code>from fluxopt import Port\n\nf = Flow(bus='elec')\nPort('grid', imports=[f])\n# f.id is now 'grid(elec)'\n</code></pre> <p>Set <code>id</code> to disambiguate when a component has multiple flows on the same bus:</p> <pre><code>f1 = Flow(bus='elec', id='base')\nf2 = Flow(bus='elec', id='peak')\nPort('plant', imports=[f1, f2])\n# f1.id = 'plant(base)', f2.id = 'plant(peak)'\n</code></pre>"},{"location":"guide/flows/#parameters-summary","title":"Parameters Summary","text":"Parameter Type Default Description <code>bus</code> <code>str</code> required Bus this flow connects to <code>id</code> <code>str</code> <code>''</code> Optional id (auto-qualified by parent) <code>size</code> <code>float \\| Sizing \\| None</code> <code>None</code> Nominal capacity [MW] or investment <code>relative_minimum</code> <code>TimeSeries</code> <code>0.0</code> Lower bound as fraction of size <code>relative_maximum</code> <code>TimeSeries</code> <code>1.0</code> Upper bound as fraction of size <code>fixed_relative_profile</code> <code>TimeSeries \\| None</code> <code>None</code> Fixed profile as fraction of size <code>effects_per_flow_hour</code> <code>dict[str, TimeSeries]</code> <code>{}</code> Effect coefficients per flow-hour <code>status</code> <code>Status \\| None</code> <code>None</code> On/off behavior (semi-continuous, startup costs, durations) <code>prior_rates</code> <code>list[float] \\| None</code> <code>None</code> Flow rates [MW] before the horizon (for status initial conditions)"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>This walkthrough builds a simple heat system end to end: define components, optimize, and inspect results.</p>"},{"location":"guide/getting-started/#the-system","title":"The System","text":"<p>A gas boiler supplies heat to meet a demand profile. We minimize fuel cost.</p> <pre><code>gas bus \u2500\u2500\u25b6 [boiler \u03b7=0.9] \u2500\u2500\u25b6 heat bus \u2500\u2500\u25b6 demand\n   \u25b2\n   \u2502\n grid (gas source, 0.04 \u20ac/kWh)\n</code></pre>"},{"location":"guide/getting-started/#step-by-step","title":"Step by Step","text":""},{"location":"guide/getting-started/#1-imports-and-timesteps","title":"1. Imports and Timesteps","text":"<pre><code>from datetime import datetime\nfrom fluxopt import Bus, Converter, Effect, Flow, Port, optimize\n\ntimesteps = [datetime(2024, 1, 1, h) for h in range(4)]\n</code></pre> <p>Timesteps can be <code>datetime</code> objects or plain integers. The duration <code>dt</code> is inferred from consecutive timestamps (here 1 h each).</p>"},{"location":"guide/getting-started/#2-define-buses","title":"2. Define Buses","text":"<p>Buses are energy carriers \u2014 nodes where flows must balance.</p> <pre><code>buses = [Bus('gas'), Bus('heat')]\n</code></pre>"},{"location":"guide/getting-started/#3-define-effects","title":"3. Define Effects","text":"<p>Effects track quantities across the horizon. Mark one as the objective.</p> <pre><code>effects = [Effect('cost', is_objective=True)]\n</code></pre>"},{"location":"guide/getting-started/#4-define-flows","title":"4. Define Flows","text":"<p>Flows carry energy on a bus. Each flow has a <code>size</code> (nominal capacity) and optional parameters like <code>fixed_relative_profile</code> or <code>effects_per_flow_hour</code>.</p> <pre><code># Gas source: up to 500 MW, costs 0.04 \u20ac/kWh\ngas_source = Flow(bus='gas', size=500, effects_per_flow_hour={'cost': 0.04})\n\n# Boiler fuel input and heat output\nfuel = Flow(bus='gas', size=300)\nheat = Flow(bus='heat', size=200)\n\n# Heat demand: 100 MW capacity, profile sets actual demand per timestep\ndemand = Flow(bus='heat', size=100, fixed_relative_profile=[0.4, 0.7, 0.5, 0.6])\n</code></pre>"},{"location":"guide/getting-started/#5-define-ports-and-converters","title":"5. Define Ports and Converters","text":"<p>Ports connect flows to the outside world (sources and sinks). Converters couple input and output flows with conversion equations.</p> <pre><code>ports = [\n    Port('grid', imports=[gas_source]),\n    Port('demand', exports=[demand]),\n]\n\nconverters = [\n    Converter.boiler('boiler', thermal_efficiency=0.9, fuel_flow=fuel, thermal_flow=heat),\n]\n</code></pre>"},{"location":"guide/getting-started/#6-optimize","title":"6. Optimize","text":"<pre><code>result = optimize(\n    timesteps=timesteps,\n    buses=buses,\n    effects=effects,\n    ports=ports,\n    converters=converters,\n)\n</code></pre>"},{"location":"guide/getting-started/#7-inspect-results","title":"7. Inspect Results","text":"<pre><code># Objective value (total cost)\nprint(result.objective)\n\n# Flow rates for a specific flow\nprint(result.flow_rate('boiler(gas)'))\n\n# All flow rates\nprint(result.flow_rates)\n\n# Effect totals\nprint(result.effect_totals)\n\n# Per-timestep effects\nprint(result.effects_temporal)\n</code></pre> <p>Flow ids are qualified as <code>{component}({bus_or_id})</code> \u2014 e.g., <code>boiler(gas)</code>, <code>grid(gas)</code>, <code>demand(heat)</code>.</p>"},{"location":"guide/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Flows \u2014 sizing, bounds, profiles, effect coefficients</li> <li>Converters \u2014 boiler, heat pump, CHP, custom conversion</li> <li>Storage \u2014 batteries, thermal storage</li> <li>Effects \u2014 multi-effect tracking, bounds, contributions</li> </ul>"},{"location":"guide/sizing/","title":"Sizing (Investment Optimization)","text":"<p><code>Sizing</code> lets the solver decide the optimal capacity of a flow or storage, instead of fixing it upfront. This models investment decisions: how large should a boiler, PV array, or battery be?</p> <p>See Sizing (Math) for the formulation.</p>"},{"location":"guide/sizing/#basic-usage","title":"Basic Usage","text":"<p>Pass a <code>Sizing</code> object instead of a numeric <code>size</code>:</p> <pre><code>from fluxopt import Flow, Sizing\n\n# Solver picks optimal size between 50 and 200 MW\nsource = Flow(bus='elec', size=Sizing(min_size=50, max_size=200, mandatory=True))\n</code></pre>"},{"location":"guide/sizing/#mandatory-vs-optional","title":"Mandatory vs Optional","text":""},{"location":"guide/sizing/#mandatory-mandatorytrue-default","title":"Mandatory (<code>mandatory=True</code>, default)","text":"<p>The component must be built. The solver picks a continuous size in <code>[min_size, max_size]</code>. No binary variable needed \u2014 faster to solve:</p> <pre><code># Always built, size in [50, 200] MW\nFlow(bus='elec', size=Sizing(min_size=50, max_size=200))\n</code></pre> <p>With <code>min_size=0</code>, the solver can choose size=0, effectively not building the component \u2014 but without the overhead of a binary indicator variable:</p> <pre><code># Size in [0, 200] MW \u2014 solver may pick 0 (no binary needed)\nFlow(bus='elec', size=Sizing(min_size=0, max_size=200))\n</code></pre>"},{"location":"guide/sizing/#optional-mandatoryfalse","title":"Optional (<code>mandatory=False</code>)","text":"<p>The solver decides whether to build the component. A binary indicator variable gates the size: either 0 (not built) or in <code>[min_size, max_size]</code>. Use this when you need <code>effects_fixed</code> (one-time costs gated by the indicator) or when <code>min_size &gt; 0</code> must be enforced only if built:</p> <pre><code># Built at [50, 200] MW or not built at all\nFlow(bus='elec', size=Sizing(min_size=50, max_size=200, mandatory=False))\n</code></pre>"},{"location":"guide/sizing/#binary-invest-fixed-size-yesno","title":"Binary Invest (fixed-size yes/no)","text":"<p>When <code>min_size == max_size</code> with <code>mandatory=False</code>, it becomes a binary invest decision \u2014 build at exactly that size or not at all:</p> <pre><code># Either build a 100 MW unit or nothing\nFlow(bus='elec', size=Sizing(min_size=100, max_size=100, mandatory=False))\n</code></pre>"},{"location":"guide/sizing/#investment-effects","title":"Investment Effects","text":"<p>Sizing can contribute to tracked effects (cost, CO\u2082, etc.) via two mechanisms:</p>"},{"location":"guide/sizing/#per-size-effects","title":"Per-Size Effects","text":"<p>Cost proportional to the invested size (e.g., \u20ac/MW or kg_CO\u2082/MWh):</p> <pre><code># 500 \u20ac/MW investment cost\nFlow(\n    bus='elec',\n    size=Sizing(min_size=50, max_size=200, mandatory=True, effects_per_size={'cost': 500}),\n)\n</code></pre>"},{"location":"guide/sizing/#fixed-effects","title":"Fixed Effects","text":"<p>One-time cost charged when the component is built. Only applies to optional sizing (<code>mandatory=False</code>) since it's gated by the binary indicator:</p> <pre><code># 10,000 \u20ac fixed cost if built, plus 500 \u20ac/MW\nFlow(\n    bus='elec',\n    size=Sizing(\n        min_size=50, max_size=200, mandatory=False,\n        effects_per_size={'cost': 500},\n        effects_fixed={'cost': 10_000},\n    ),\n)\n</code></pre>"},{"location":"guide/sizing/#storage-sizing","title":"Storage Sizing","text":"<p><code>Storage.capacity</code> also accepts <code>Sizing</code> for optimizing battery or tank size:</p> <pre><code>from fluxopt import Flow, Sizing, Storage\n\ncharge = Flow(bus='elec', size=50)\ndischarge = Flow(bus='elec', size=50)\n\nbattery = Storage(\n    'battery',\n    charging=charge,\n    discharging=discharge,\n    capacity=Sizing(min_size=100, max_size=1000, mandatory=True, effects_per_size={'cost': 200}),\n)\n</code></pre>"},{"location":"guide/sizing/#interaction-with-other-features","title":"Interaction with Other Features","text":""},{"location":"guide/sizing/#with-bounds","title":"With Bounds","text":"<p>Relative bounds (<code>relative_minimum</code>, <code>relative_maximum</code>) are fractions of the optimized size variable, not a fixed number. If the solver picks 80 MW and <code>relative_minimum=0.3</code>, the minimum flow rate is 24 MW.</p>"},{"location":"guide/sizing/#with-status","title":"With Status","text":"<p>When a flow has both <code>Sizing</code> and <code>Status</code>, a big-M formulation decouples the binary on/off from the continuous size. See Status for details.</p>"},{"location":"guide/sizing/#full-example","title":"Full Example","text":"<p>Two competing sources \u2014 the solver decides whether to invest in a cheaper source:</p> <pre><code>from datetime import datetime\nfrom fluxopt import Bus, Effect, Flow, Port, Sizing, optimize\n\ntimesteps = [datetime(2024, 1, 1, h) for h in range(4)]\n\ndemand = Flow(bus='elec', size=100, fixed_relative_profile=[0.5, 0.5, 0.5, 0.5])\n\n# Always-available expensive source\ngrid = Flow(bus='elec', size=200, effects_per_flow_hour={'cost': 0.10})\n\n# Optional cheap source with investment cost\nsolar = Flow(\n    bus='elec',\n    size=Sizing(min_size=50, max_size=200, mandatory=False, effects_per_size={'cost': 20}),\n    effects_per_flow_hour={'cost': 0.01},\n    fixed_relative_profile=[0.0, 0.8, 0.8, 0.0],  # only available midday\n)\n\nresult = optimize(\n    timesteps=timesteps,\n    buses=[Bus('elec')],\n    effects=[Effect('cost', is_objective=True)],\n    ports=[\n        Port('grid', imports=[grid]),\n        Port('solar', imports=[solar]),\n        Port('demand', exports=[demand]),\n    ],\n)\n\nprint(f\"Objective: {result.objective:.2f}\")\n</code></pre>"},{"location":"guide/sizing/#parameters-summary","title":"Parameters Summary","text":"Parameter Type Default Description <code>min_size</code> <code>float</code> required Minimum size if invested <code>max_size</code> <code>float</code> required Maximum size <code>mandatory</code> <code>bool</code> <code>True</code> If True, must be built (no binary indicator) <code>effects_per_size</code> <code>dict[str, float]</code> <code>{}</code> Effect cost per unit size (e.g., \u20ac/MW) <code>effects_fixed</code> <code>dict[str, float]</code> <code>{}</code> Fixed effect cost if built (optional only)"},{"location":"guide/status/","title":"Status (On/Off Behavior)","text":"<p><code>Status</code> adds binary on/off behavior to a flow. This enables:</p> <ul> <li>Semi-continuous dispatch: flow is either off (0) or within its bounds</li> <li>Startup costs: one-time cost each time a unit turns on</li> <li>Running costs: cost per hour while the unit is on</li> <li>Duration constraints: minimum/maximum consecutive up- and downtime</li> </ul> <p>See Status (Math) for the formulation.</p>"},{"location":"guide/status/#basic-usage","title":"Basic Usage","text":"<pre><code>from fluxopt import Flow, Status\n\n# Semi-continuous: flow is either 0 or in [30%, 100%] of size\nboiler_heat = Flow(\n    bus='heat',\n    size=100,\n    relative_minimum=0.3,\n    status=Status(),\n)\n</code></pre> <p>Without <code>Status</code>, relative bounds give a continuous range <code>[30, 100]</code> MW. With <code>Status</code>, the flow becomes semi-continuous: <code>{0} U [30, 100]</code> MW.</p>"},{"location":"guide/status/#startup-running-costs","title":"Startup &amp; Running Costs","text":""},{"location":"guide/status/#startup-costs","title":"Startup Costs","text":"<p>A one-time cost charged each time the unit switches from off to on:</p> <pre><code># 50 \u20ac per startup event\nFlow(\n    bus='heat',\n    size=100,\n    status=Status(effects_per_startup={'cost': 50}),\n)\n</code></pre> <p>Startup costs discourage frequent cycling. The solver may keep a unit running through a low-demand period rather than paying repeated startup costs.</p>"},{"location":"guide/status/#running-costs","title":"Running Costs","text":"<p>A per-hour cost while the unit is on, independent of the flow rate:</p> <pre><code># 5 \u20ac/h while running (regardless of load)\nFlow(\n    bus='heat',\n    size=100,\n    status=Status(effects_per_running_hour={'cost': 5}),\n)\n</code></pre> <p>Both can be time-varying:</p> <pre><code>Status(\n    effects_per_startup={'cost': [50, 60, 50]},\n    effects_per_running_hour={'cost': [5, 8, 5]},\n)\n</code></pre>"},{"location":"guide/status/#duration-constraints","title":"Duration Constraints","text":""},{"location":"guide/status/#minimum-uptime","title":"Minimum Uptime","text":"<p>Once turned on, the unit must stay on for at least this many hours:</p> <pre><code># Must run for at least 3 hours once started\nFlow(bus='heat', size=100, status=Status(min_uptime=3))\n</code></pre>"},{"location":"guide/status/#maximum-uptime","title":"Maximum Uptime","text":"<p>The unit cannot run for more than this many consecutive hours:</p> <pre><code># Must shut down after 8 hours of continuous operation\nFlow(bus='heat', size=100, status=Status(max_uptime=8))\n</code></pre>"},{"location":"guide/status/#minimum-downtime","title":"Minimum Downtime","text":"<p>Once turned off, the unit must stay off for at least this many hours:</p> <pre><code># Must stay off for at least 2 hours after shutdown\nFlow(bus='heat', size=100, status=Status(min_downtime=2))\n</code></pre>"},{"location":"guide/status/#maximum-downtime","title":"Maximum Downtime","text":"<p>The unit cannot stay off for more than this many consecutive hours:</p> <pre><code># Must restart within 4 hours of being off\nFlow(bus='heat', size=100, status=Status(max_downtime=4))\n</code></pre>"},{"location":"guide/status/#combining-durations","title":"Combining Durations","text":"<p>All duration constraints can be combined:</p> <pre><code>Status(min_uptime=3, max_uptime=8, min_downtime=2)\n</code></pre> <p>Duration values are in hours. With sub-hourly timesteps (e.g., <code>dt=0.5</code>), a <code>min_uptime=2</code> means the unit must stay on for 4 consecutive timesteps.</p>"},{"location":"guide/status/#prior-historical-state","title":"Prior (Historical State)","text":"<p><code>Flow.prior_rates</code> provides the flow rates from timesteps before the optimization horizon. This lets the solver know the initial on/off state and how long the unit has been running or idle:</p> <pre><code># Unit was running at 80 MW in the previous timestep\nFlow(bus='heat', size=100, status=Status(min_uptime=3), prior_rates=[80])\n\n# Unit was off in the previous 2 timesteps\nFlow(bus='heat', size=100, status=Status(min_downtime=2), prior_rates=[0, 0])\n\n# Unit was running for the last 4 timesteps\nFlow(bus='heat', size=100, status=Status(min_uptime=3), prior_rates=[50, 60, 70, 80])\n</code></pre> <p>Without <code>prior_rates</code>, the initial state is free (solver decides).</p> <p>The prior rates are used to:</p> <ol> <li>Set initial on/off state: last value &gt; 0 means on, = 0 means off</li> <li>Compute previous uptime/downtime: consecutive hours in the current state    at the end of the prior, used for duration constraint carryover</li> </ol>"},{"location":"guide/status/#interaction-with-sizing","title":"Interaction with Sizing","text":"<p>When a flow has both <code>Status</code> and <code>Sizing</code>, a big-M formulation decouples the binary on/off from the continuous size variable:</p> <pre><code>from fluxopt import Sizing, Status\n\nFlow(\n    bus='heat',\n    size=Sizing(min_size=50, max_size=200, mandatory=True),\n    relative_minimum=0.3,\n    status=Status(effects_per_startup={'cost': 100}),\n)\n</code></pre> <p>An additional constraint <code>on &lt;= size</code> prevents the unit from being \"on\" when its invested size is zero (relevant for optional sizing).</p> <p>See Status (Math) for the big-M formulation.</p>"},{"location":"guide/status/#full-example","title":"Full Example","text":"<p>A gas boiler with startup costs and minimum run time:</p> <pre><code>from datetime import datetime\nfrom fluxopt import Bus, Converter, Effect, Flow, Port, Status, optimize\n\ntimesteps = [datetime(2024, 1, 1, h) for h in range(6)]\n\ndemand = Flow(bus='heat', size=100, fixed_relative_profile=[0.3, 0.8, 0.2, 0.1, 0.7, 0.4])\n\nfuel = Flow(bus='gas', size=200)\nheat_out = Flow(\n    bus='heat',\n    size=100,\n    relative_minimum=0.3,\n    status=Status(\n        min_uptime=2,\n        min_downtime=1,\n        effects_per_startup={'cost': 50},\n        effects_per_running_hour={'cost': 5},\n    ),\n)\ngas_source = Flow(bus='gas', size=500, effects_per_flow_hour={'cost': 0.04})\n\nresult = optimize(\n    timesteps=timesteps,\n    buses=[Bus('gas'), Bus('heat')],\n    effects=[Effect('cost', is_objective=True)],\n    ports=[Port('grid', imports=[gas_source]), Port('demand', exports=[demand])],\n    converters=[Converter.boiler('boiler', 0.9, fuel, heat_out)],\n)\n</code></pre>"},{"location":"guide/status/#parameters-summary","title":"Parameters Summary","text":""},{"location":"guide/status/#status","title":"Status","text":"Parameter Type Default Description <code>min_uptime</code> <code>float \\| None</code> <code>None</code> Minimum consecutive on-hours <code>max_uptime</code> <code>float \\| None</code> <code>None</code> Maximum consecutive on-hours <code>min_downtime</code> <code>float \\| None</code> <code>None</code> Minimum consecutive off-hours <code>max_downtime</code> <code>float \\| None</code> <code>None</code> Maximum consecutive off-hours <code>effects_per_running_hour</code> <code>dict[str, TimeSeries]</code> <code>{}</code> Effect cost per running hour <code>effects_per_startup</code> <code>dict[str, TimeSeries]</code> <code>{}</code> Effect cost per startup event"},{"location":"guide/status/#flowprior","title":"Flow.prior","text":"Parameter Type Default Description <code>prior_rates</code> <code>list[float] \\| None</code> <code>None</code> Flow rates [MW] before the horizon"},{"location":"guide/storage/","title":"Storage","text":"<p>A <code>Storage</code> models energy storage with charge/discharge flows, capacity, efficiency, and self-discharge.</p> <p>See Storage (Math) for the formulation.</p>"},{"location":"guide/storage/#basic-construction","title":"Basic Construction","text":"<p>A storage needs two flows (charging and discharging) on the same bus:</p> <pre><code>from fluxopt import Flow, Storage\n\ncharge = Flow(bus='elec', size=50)     # max charge rate 50 MW\ndischarge = Flow(bus='elec', size=50)  # max discharge rate 50 MW\n\nbattery = Storage('battery', charging=charge, discharging=discharge, capacity=100.0)\n</code></pre> <p>Flow ids are auto-qualified: <code>battery(charge)</code> and <code>battery(discharge)</code>.</p>"},{"location":"guide/storage/#parameters","title":"Parameters","text":""},{"location":"guide/storage/#capacity","title":"Capacity","text":"<p><code>capacity</code> sets the maximum stored energy \\(\\bar{E}_s\\) in MWh:</p> <pre><code>battery = Storage('battery', charging=charge, discharging=discharge, capacity=100.0)\n</code></pre>"},{"location":"guide/storage/#efficiency","title":"Efficiency","text":"<p><code>eta_charge</code> and <code>eta_discharge</code> set round-trip efficiency. Losses are applied during charging and discharging respectively:</p> <pre><code>battery = Storage(\n    'battery', charging=charge, discharging=discharge,\n    capacity=100.0,\n    eta_charge=0.95,\n    eta_discharge=0.95,\n)\n</code></pre> <p>With these values, a full charge/discharge cycle retains 90.25% of the energy.</p>"},{"location":"guide/storage/#self-discharge","title":"Self-Discharge","text":"<p><code>relative_loss_per_hour</code> sets the fraction of stored energy lost per hour:</p> <pre><code>battery = Storage(\n    'battery', charging=charge, discharging=discharge,\n    capacity=100.0,\n    relative_loss_per_hour=0.001,  # 0.1%/h\n)\n</code></pre>"},{"location":"guide/storage/#prior-level-and-cyclic-constraint","title":"Prior Level and Cyclic Constraint","text":"<p><code>prior_level</code> sets the energy level at the start of the horizon as an absolute value in MWh. <code>cyclic</code> enforces that the storage ends at the same level it started:</p> <pre><code># Fixed initial level (absolute MWh), no cyclic constraint\nbattery = Storage(..., prior_level=50.0, cyclic=False)\n\n# Unconstrained initial level (optimizer chooses), cyclic (default)\nbattery = Storage(..., prior_level=None, cyclic=True)\n</code></pre> <p>The default is <code>prior_level=None</code> (unconstrained) and <code>cyclic=True</code>.</p>"},{"location":"guide/storage/#level-bounds","title":"Level Bounds","text":"<p><code>relative_minimum_level</code> and <code>relative_maximum_level</code> limit the SOC as fractions of capacity:</p> <pre><code>battery = Storage(\n    'battery', charging=charge, discharging=discharge,\n    capacity=100.0,\n    relative_minimum_level=0.2,  # never below 20%\n    relative_maximum_level=0.9,  # never above 90%\n)\n</code></pre>"},{"location":"guide/storage/#full-example","title":"Full Example","text":"<p>Battery arbitrage \u2014 charge in cheap hours, discharge in expensive hours:</p> <pre><code>from datetime import datetime\nfrom fluxopt import Bus, Effect, Flow, Port, Storage, optimize\n\ntimesteps = [datetime(2024, 1, 1, h) for h in range(4)]\nprices = [0.02, 0.08, 0.02, 0.08]\n\nsource = Flow(bus='elec', size=200, effects_per_flow_hour={'cost': prices})\ndemand = Flow(bus='elec', size=100, fixed_relative_profile=[0.5, 0.5, 0.5, 0.5])\n\ncharge = Flow(bus='elec', size=50)\ndischarge = Flow(bus='elec', size=50)\nbattery = Storage('battery', charging=charge, discharging=discharge, capacity=100.0)\n\nresult = optimize(\n    timesteps=timesteps,\n    buses=[Bus('elec')],\n    effects=[Effect('cost', is_objective=True)],\n    ports=[Port('grid', imports=[source]), Port('demand', exports=[demand])],\n    storages=[battery],\n)\n\nprint(result.flow_rate('battery(charge)'))\nprint(result.flow_rate('battery(discharge)'))\nprint(result.storage_level('battery'))\n</code></pre>"},{"location":"guide/storage/#parameters-summary","title":"Parameters Summary","text":"Parameter Type Default Description <code>id</code> <code>str</code> required Storage identifier <code>charging</code> <code>Flow</code> required Charging flow <code>discharging</code> <code>Flow</code> required Discharging flow <code>capacity</code> <code>float \\| Sizing \\| None</code> <code>None</code> Maximum stored energy [MWh] or investment <code>eta_charge</code> <code>TimeSeries</code> <code>1.0</code> Charging efficiency <code>eta_discharge</code> <code>TimeSeries</code> <code>1.0</code> Discharging efficiency <code>relative_loss_per_hour</code> <code>TimeSeries</code> <code>0.0</code> Self-discharge rate [1/h] <code>prior_level</code> <code>float \\| None</code> <code>None</code> Initial energy level [MWh], None = unconstrained <code>cyclic</code> <code>bool</code> <code>True</code> End level must equal start level <code>relative_minimum_level</code> <code>TimeSeries</code> <code>0.0</code> Min SOC as fraction of capacity <code>relative_maximum_level</code> <code>TimeSeries</code> <code>1.0</code> Max SOC as fraction of capacity"},{"location":"math/bus-balance/","title":"Bus Balance","text":""},{"location":"math/bus-balance/#formulation","title":"Formulation","text":"<p>Every bus \\(b\\) must be balanced at every timestep \u2014 total outflow equals total inflow:</p> \\[ \\sum_{f \\in \\mathcal{F}_b^{\\text{out}}} P_{f,t} - \\sum_{f \\in \\mathcal{F}_b^{\\text{in}}} P_{f,t} = 0 \\quad \\forall \\, b \\in \\mathcal{B}, \\; t \\in \\mathcal{T} \\] <p>where:</p> <ul> <li>\\(\\mathcal{F}_b^{\\text{out}}\\) \u2014 flows that produce into bus \\(b\\) (imports of ports and outputs of converters)</li> <li>\\(\\mathcal{F}_b^{\\text{in}}\\) \u2014 flows that consume from bus \\(b\\) (exports of ports and inputs of converters)</li> </ul> <p>The sign convention uses coefficients: \\(+1\\) for flows producing into the bus and \\(-1\\) for flows consuming from the bus. The constraint is then:</p> \\[ \\sum_{f \\in \\mathcal{F}_b} \\text{coeff}_{b,f} \\cdot P_{f,t} = 0 \\quad \\forall \\, b, t \\]"},{"location":"math/bus-balance/#parameters","title":"Parameters","text":"Symbol Description Reference \\(\\mathcal{F}_b^{\\text{out}}\\) Flows producing into bus \\(b\\) <code>bus_coeff[f.id] = +1</code> (port imports, converter outputs, storage discharging) \\(\\mathcal{F}_b^{\\text{in}}\\) Flows consuming from bus \\(b\\) <code>bus_coeff[f.id] = -1</code> (port exports, converter inputs, storage charging) \\(P_{f,t}\\) Flow rate variable <code>flow_rate[flow, time]</code> <p>See Notation for the full symbol table.</p>"},{"location":"math/bus-balance/#example","title":"Example","text":"<p>A thermal bus with a boiler output (3 MW) and a demand input (3 MW):</p> \\[ \\underbrace{P_{\\text{boiler\\_th},t}}_{+1 \\times 3} + \\underbrace{(-1) \\cdot P_{\\text{demand},t}}_{-1 \\times 3} = 0 \\quad \\checkmark \\]"},{"location":"math/converters/","title":"Linear Conversion","text":""},{"location":"math/converters/#formulation","title":"Formulation","text":"<p>A <code>Converter</code> enforces linear coupling between its input and output flows. Each conversion equation requires:</p> \\[ \\sum_{f} a_{f} \\cdot P_{f,t} = 0 \\quad \\forall \\, \\text{converter}, \\; \\text{eq\\_idx}, \\; t \\in \\mathcal{T} \\] <p>where \\(a_f\\) is the conversion coefficient for flow \\(f\\). A converter can have multiple equations (one per row in <code>conversion_factors</code>), allowing multi-output devices like CHP plants.</p>"},{"location":"math/converters/#parameters","title":"Parameters","text":"Symbol Description Reference \\(a_f\\) Conversion coefficient <code>Converter.conversion_factors</code> \\(P_{f,t}\\) Flow rate variable <code>flow_rate[flow, time]</code> <p>See Notation for the full symbol table.</p>"},{"location":"math/converters/#examples","title":"Examples","text":""},{"location":"math/converters/#boiler","title":"Boiler","text":"<p>A gas boiler with thermal efficiency \\(\\eta_{\\text{th}} = 0.9\\):</p> \\[ \\eta_{\\text{th}} \\cdot P_{\\text{gas},t} - P_{\\text{th},t} = 0 \\] \\[ 0.9 \\cdot P_{\\text{gas},t} = P_{\\text{th},t} \\] <p>So 10 MW gas input produces 9 MW thermal output.</p> <pre><code>Converter.boiler(\"boiler\", thermal_efficiency=0.9, fuel_flow=gas, thermal_flow=th)\n# conversion_factors = [{gas.id: 0.9, th.id: -1}]\n</code></pre>"},{"location":"math/converters/#power-to-heat","title":"Power-to-Heat","text":"<p>An electric resistance heater with efficiency \\(\\eta = 0.99\\):</p> \\[ \\eta \\cdot P_{\\text{el},t} - P_{\\text{th},t} = 0 \\] <pre><code>Converter.power2heat(\"p2h\", efficiency=0.99, electrical_flow=el, thermal_flow=th)\n# conversion_factors = [{el.id: 0.99, th.id: -1}]\n</code></pre>"},{"location":"math/converters/#heat-pump","title":"Heat Pump","text":"<p>A heat pump with COP = 3.5 has two conversion equations \u2014 COP definition and energy balance:</p> \\[ \\text{COP} \\cdot P_{\\text{el},t} - P_{\\text{th},t} = 0 \\] \\[ P_{\\text{el},t} + P_{\\text{src},t} - P_{\\text{th},t} = 0 \\] <p>So 1 MW electrical input draws 2.5 MW from the environment and produces 3.5 MW thermal output.</p> <pre><code>Converter.heat_pump(\"hp\", cop=3.5, electrical_flow=el, source_flow=src, thermal_flow=th)\n# conversion_factors = [{el.id: 3.5, th.id: -1}, {el.id: 1, src.id: 1, th.id: -1}]\n</code></pre>"},{"location":"math/converters/#chp-combined-heat-and-power","title":"CHP (Combined Heat and Power)","text":"<p>A CHP with \\(\\eta_{\\text{el}} = 0.4\\) and \\(\\eta_{\\text{th}} = 0.5\\) has two conversion equations:</p> \\[ \\eta_{\\text{el}} \\cdot P_{\\text{fuel},t} - P_{\\text{el},t} = 0 \\] \\[ \\eta_{\\text{th}} \\cdot P_{\\text{fuel},t} - P_{\\text{th},t} = 0 \\] <p>So 10 MW fuel input produces 4 MW electrical + 5 MW thermal.</p> <pre><code>Converter.chp(\"chp\", eta_el=0.4, eta_th=0.5,\n                     fuel_flow=fuel, electrical_flow=el, thermal_flow=th)\n# conversion_factors = [\n#     {fuel.id: 0.4, el.id: -1},\n#     {fuel.id: 0.5, th.id: -1},\n# ]\n</code></pre>"},{"location":"math/converters/#time-varying-coefficients","title":"Time-Varying Coefficients","text":"<p>Conversion coefficients can be time-varying (e.g., a heat pump with hourly COP from weather data). Pass a list or array instead of a scalar:</p> <pre><code>cop_profile = [3.2, 3.5, 3.8, 3.1]  # one value per timestep\nConverter.heat_pump(\"hp\", cop=cop_profile, electrical_flow=el, source_flow=src, thermal_flow=th)\n</code></pre>"},{"location":"math/effects/","title":"Effect Tracking &amp; Bounding","text":""},{"location":"math/effects/#overview","title":"Overview","text":"<p>Effects represent quantities that are tracked across the optimization horizon (e.g., cost, CO\u2082 emissions, primary energy). One effect is designated as the objective to minimize.</p> <p>Effects are split into two domains:</p> <ul> <li>Temporal (with time dimension): per-timestep flow contributions, status costs</li> <li>Periodic (without time dimension): sizing costs, fixed yearly costs</li> </ul> <p>Both domains support cross-effect chains via <code>contribution_from</code>.</p>"},{"location":"math/effects/#temporal-domain","title":"Temporal Domain","text":"<p>Each effect accumulates contributions from all flows at each timestep:</p> \\[ \\Phi_{k,t}^{\\text{temporal}} = \\underbrace{\\sum_{f \\in \\mathcal{F}} c_{f,k,t} \\cdot P_{f,t} \\cdot \\Delta t_t}_{\\text{direct flow contributions}} + \\underbrace{\\sum_{j \\in \\mathcal{K}} \\alpha_{k,j,t} \\cdot \\Phi_{j,t}^{\\text{temporal}}}_{\\text{cross-effect contributions}} \\quad \\forall \\, k, t \\] <p>The coefficient \\(c_{f,k,t}\\) specifies how much of effect \\(k\\) is produced per flow-hour of flow \\(f\\) (e.g., \u20ac/MWh for cost, kg/MWh for emissions).</p> <p>The cross-effect factor \\(\\alpha_{k,j,t}\\) can be time-varying (<code>contribution_from_per_hour</code>) or constant (<code>contribution_from</code>). Because \\(\\Phi_{k,t}^{\\text{temporal}}\\) is a variable, the solver resolves multi-level chains (e.g., PE \u2192 CO\u2082 \u2192 cost) automatically.</p>"},{"location":"math/effects/#periodic-domain","title":"Periodic Domain","text":"<p>Sizing costs and fixed costs (not time-varying) are accumulated per effect:</p> \\[ \\Phi_k^{\\text{periodic}} = \\underbrace{\\Phi_k^{\\text{invest,direct}}}_{\\text{direct sizing costs}} + \\underbrace{\\sum_{j \\in \\mathcal{K}} \\alpha_{k,j} \\cdot \\Phi_j^{\\text{periodic}}}_{\\text{cross-effect contributions}} \\quad \\forall \\, k \\] <p>where the direct investment term is:</p> \\[ \\Phi_k^{\\text{invest,direct}} = \\sum_{f} \\gamma_{f,k} \\cdot S_f + \\sum_{f} \\phi_{f,k} \\cdot y_f + \\sum_{s} \\gamma_{s,k} \\cdot S_s + \\sum_{s} \\phi_{s,k} \\cdot y_s \\] <p>Because \\(\\Phi_k^{\\text{periodic}}\\) is a variable (not an expression), the solver resolves multi-level chains correctly: if PE has sizing costs and CO\u2082 depends on PE and cost depends on CO\u2082, the chain propagates through the periodic domain just as it does through the temporal domain.</p>"},{"location":"math/effects/#cross-effect-contributions","title":"Cross-Effect Contributions","text":"<p>An effect can include a weighted fraction of another effect's value via <code>contribution_from</code>. This enables patterns like carbon pricing (CO\u2082 \u2192 cost) or transitive chains (PE \u2192 CO\u2082 \u2192 cost).</p> <p>The scalar factor \\(\\alpha_{k,j}\\) from <code>contribution_from</code> applies to both domains. The time-varying factor from <code>contribution_from_per_hour</code> overrides the temporal factor only.</p>"},{"location":"math/effects/#validation","title":"Validation","text":"<p>Self-references (\\(\\alpha_{k,k}\\)) and circular dependencies (\\(k \\to j \\to \\cdots \\to k\\)) are rejected at build time to prevent singular systems.</p>"},{"location":"math/effects/#total-aggregation","title":"Total Aggregation","text":"<p>The total effect combines both domains:</p> \\[ \\Phi_k = \\sum_{t \\in \\mathcal{T}} \\Phi_{k,t}^{\\text{temporal}} \\cdot w_t + \\Phi_k^{\\text{periodic}} \\quad \\forall \\, k \\in \\mathcal{K} \\] <p>Weights \\(w_t\\) allow scaling timesteps (e.g., a representative week scaled to a year).</p>"},{"location":"math/effects/#total-bounds","title":"Total Bounds","text":"<p>Upper and lower bounds on the total effect over the entire horizon:</p> \\[ \\underline{\\Phi}_k \\leq \\Phi_k \\leq \\bar{\\Phi}_k \\] <p>This is useful for emission caps or budget constraints.</p>"},{"location":"math/effects/#per-timestep-bounds","title":"Per-Timestep Bounds","text":"<p>Bounds on the effect value at each timestep:</p> \\[ \\underline{\\Phi}_{k,t} \\leq \\Phi_{k,t} \\leq \\bar{\\Phi}_{k,t} \\quad \\forall \\, t \\in \\mathcal{T} \\] <p>This enforces per-hour limits (e.g., maximum hourly emissions).</p>"},{"location":"math/effects/#parameters","title":"Parameters","text":"Symbol Description Reference \\(\\Phi_{k,t}^{\\text{temporal}}\\) Per-timestep effect variable <code>effect_temporal[effect, time]</code> \\(\\Phi_k^{\\text{periodic}}\\) Periodic effect variable (sizing, fixed costs) <code>effect_periodic[effect]</code> \\(\\Phi_k\\) Total effect variable <code>effect_total[effect]</code> \\(c_{f,k,t}\\) Effect coefficient per flow-hour <code>Flow.effects_per_flow_hour</code> \\(\\alpha_{k,j,t}\\) Cross-effect contribution factor (per hour) <code>Effect.contribution_from_per_hour</code> \\(\\alpha_{k,j}\\) Cross-effect contribution factor (scalar) <code>Effect.contribution_from</code> \\(P_{f,t}\\) Flow rate variable <code>flow_rate[flow, time]</code> \\(\\Delta t_t\\) Timestep duration dt \\(w_t\\) Timestep weight weights \\(\\bar{\\Phi}_k\\) Maximum total <code>Effect.maximum_total</code> \\(\\underline{\\Phi}_k\\) Minimum total <code>Effect.minimum_total</code> \\(\\bar{\\Phi}_{k,t}\\) Maximum per hour <code>Effect.maximum_per_hour</code> \\(\\underline{\\Phi}_{k,t}\\) Minimum per hour <code>Effect.minimum_per_hour</code> <p>See Notation for the full symbol table.</p>"},{"location":"math/effects/#examples","title":"Examples","text":""},{"location":"math/effects/#direct-effects","title":"Direct effects","text":"<p>A system with two effects \u2014 cost (objective) and CO\u2082 (capped at 1000 kg):</p> <pre><code>effects = [\n    Effect(\"cost\", unit=\"\u20ac\", is_objective=True),\n    Effect(\"CO2\", unit=\"kg\", maximum_total=1000),\n]\n</code></pre> <p>A gas flow with both effect coefficients:</p> <pre><code>gas_flow = Flow(\"gas\", bus=\"gas_bus\", effects_per_flow_hour={\"cost\": 30, \"CO2\": 0.2})\n</code></pre> <p>At timestep \\(t\\) with \\(P_{\\text{gas},t} = 5\\) MW and \\(\\Delta t = 1\\) h:</p> <ul> <li>\\(\\Phi_{\\text{cost},t} = 30 \\times 5 \\times 1 = 150\\) \u20ac</li> <li>\\(\\Phi_{\\text{CO\u2082},t} = 0.2 \\times 5 \\times 1 = 1.0\\) kg</li> </ul>"},{"location":"math/effects/#carbon-pricing-via-contribution_from","title":"Carbon pricing via <code>contribution_from</code>","text":"<p>CO\u2082 priced at 50 \u20ac/t into the cost effect:</p> <pre><code>effects = [\n    Effect(\"cost\", is_objective=True, contribution_from={\"co2\": 50}),\n    Effect(\"co2\", unit=\"kg\"),\n]\n</code></pre> <p>With \\(\\alpha_{\\text{cost,co2}} = 50\\), the per-timestep cost becomes:</p> \\[ \\Phi_{\\text{cost},t} = c_{\\text{cost}} \\cdot P_t \\cdot \\Delta t + 50 \\cdot \\Phi_{\\text{co2},t} \\] <p>The CO\u2082 total itself is not affected \u2014 <code>contribution_from</code> is one-directional.</p>"},{"location":"math/flows/","title":"Flows","text":"<p>A flow represents energy transfer on a bus. This page covers the full mathematical model: sizing, bounds, fixed profiles, and effect contributions.</p>"},{"location":"math/flows/#flow-rate-variable","title":"Flow Rate Variable","text":"<p>Each flow \\(f\\) has a non-negative rate variable \\(P_{f,t}\\) at each timestep:</p> \\[ P_{f,t} \\geq 0 \\quad \\forall \\, f \\in \\mathcal{F}, \\; t \\in \\mathcal{T} \\]"},{"location":"math/flows/#sizing","title":"Sizing","text":"<p>The nominal capacity \\(\\bar{P}_f\\) (<code>Flow.size</code>) sets the scale for all relative parameters. When no capacity is specified (\\(\\bar{P}_f = \\infty\\)), the flow is unbounded above.</p>"},{"location":"math/flows/#bounds","title":"Bounds","text":""},{"location":"math/flows/#sized-flows","title":"Sized Flows","text":"<p>When a flow has a nominal capacity \\(\\bar{P}_f\\), the flow rate is bounded by relative minimum and maximum profiles:</p> \\[ \\bar{P}_f \\cdot \\underline{p}_{f,t} \\leq P_{f,t} \\leq \\bar{P}_f \\cdot \\bar{p}_{f,t} \\quad \\forall \\, f, t \\] <p>By default, \\(\\underline{p}_{f,t} = 0\\) and \\(\\bar{p}_{f,t} = 1\\), so the bounds simplify to \\(0 \\leq P_{f,t} \\leq \\bar{P}_f\\).</p>"},{"location":"math/flows/#unsized-flows","title":"Unsized Flows","text":"<p>When no capacity is specified (\\(\\bar{P}_f = \\infty\\)), the flow is unbounded above:</p> \\[ 0 \\leq P_{f,t} \\quad \\forall \\, f, t \\]"},{"location":"math/flows/#fixed-profile","title":"Fixed Profile","text":"<p>When <code>Flow.fixed_relative_profile</code> (\\(\\pi_{f,t}\\)) is set, the flow rate is fixed to a profile scaled by the capacity:</p> \\[ P_{f,t} = \\bar{P}_f \\cdot \\pi_{f,t} \\quad \\forall \\, f, t \\] <p>This is implemented by setting both lower and upper bounds equal to the profile value.</p>"},{"location":"math/flows/#sizing-investment","title":"Sizing (Investment)","text":"<p>When <code>Flow.size</code> is a <code>Sizing</code> object, the fixed capacity is replaced by a decision variable. See Sizing for the full formulation.</p>"},{"location":"math/flows/#status-onoff","title":"Status (On/Off)","text":"<p>When <code>Flow.status</code> is set, binary on/off behavior is added. The flow becomes semi-continuous: \\(\\{0\\} \\cup [\\underline{P}, \\bar{P}]\\). See Status for the full formulation.</p>"},{"location":"math/flows/#effect-contributions","title":"Effect Contributions","text":"<p>Each flow can contribute to tracked effects (cost, emissions, ...). The per-timestep contribution of flow \\(f\\) to effect \\(k\\) is:</p> \\[ c_{f,k,t} \\cdot P_{f,t} \\cdot \\Delta t_t \\] <p>where \\(c_{f,k,t}\\) is the effect coefficient per flow-hour (<code>Flow.effects_per_flow_hour</code>). These contributions feed into the effect tracking equations.</p>"},{"location":"math/flows/#parameters","title":"Parameters","text":"Symbol Description Reference \\(P_{f,t}\\) Flow rate variable <code>flow_rate[flow, time]</code> \\(\\bar{P}_f\\) Nominal capacity <code>Flow.size</code> \\(\\underline{p}_{f,t}\\) Relative lower bound <code>Flow.relative_minimum</code> \\(\\bar{p}_{f,t}\\) Relative upper bound <code>Flow.relative_maximum</code> \\(\\pi_{f,t}\\) Fixed relative profile <code>Flow.fixed_relative_profile</code> \\(c_{f,k,t}\\) Effect coefficient per flow-hour <code>Flow.effects_per_flow_hour</code> \\(\\Delta t_t\\) Timestep duration dt <p>See Notation for the full symbol table.</p>"},{"location":"math/flows/#examples","title":"Examples","text":""},{"location":"math/flows/#sized-flow-with-minimum-load","title":"Sized Flow with Minimum Load","text":"<p>A boiler with capacity \\(\\bar{P} = 10\\) MW, minimum load \\(\\underline{p} = 0.3\\), maximum load \\(\\bar{p} = 1.0\\):</p> \\[ 10 \\times 0.3 \\leq P_t \\leq 10 \\times 1.0 \\quad \\Rightarrow \\quad 3 \\leq P_t \\leq 10 \\; \\text{MW} \\]"},{"location":"math/flows/#fixed-demand-profile","title":"Fixed Demand Profile","text":"<p>A demand of 100 MW capacity with profile \\(\\pi = [0.4, 0.7, 0.5, 0.6]\\):</p> \\[ P_t = 100 \\cdot \\pi_t \\quad \\Rightarrow \\quad P = [40, 70, 50, 60] \\; \\text{MW} \\]"},{"location":"math/flows/#effect-contribution","title":"Effect Contribution","text":"<p>A gas flow with cost coefficient \\(c = 0.04\\) \u20ac/MWh, rate \\(P = 5\\) MW, duration \\(\\Delta t = 1\\) h:</p> \\[ 0.04 \\times 5 \\times 1 = 0.2 \\; \\text{\u20ac} \\]"},{"location":"math/notation/","title":"Notation","text":"<p>This page defines the canonical symbols used throughout the mathematical formulation. Each symbol maps to a specific field or variable in the code.</p>"},{"location":"math/notation/#sets-indices","title":"Sets &amp; Indices","text":"Symbol Description Code \\(t \\in \\mathcal{T}\\) Timesteps <code>time</code> dimension \\(f \\in \\mathcal{F}\\) Flows <code>flow</code> dimension \\(b \\in \\mathcal{B}\\) Buses <code>bus</code> dimension \\(s \\in \\mathcal{S}\\) Storages <code>storage</code> dimension \\(k \\in \\mathcal{K}\\) Effects (cost, CO\u2082, \u2026) <code>effect</code> dimension \\(j \\in \\mathcal{K}\\) Source effect (cross-effect) <code>source_effect</code> dimension"},{"location":"math/notation/#variables","title":"Variables","text":"Symbol Code Domain Unit Description \\(P_{f,t}\\) <code>flow--rate[flow, time]</code> \\(\\geq 0\\) MW Flow rate \\(E_{s,t}\\) <code>storage--level[storage, time]</code> \\(\\geq 0\\) MWh Stored energy \\(\\Phi_{k,t}^{\\text{temporal}}\\) <code>effect--temporal[effect, time]</code> \\(\\mathbb{R}\\) varies Temporal (per-timestep) effect \\(\\Phi_k^{\\text{periodic}}\\) <code>effect--periodic[effect]</code> \\(\\mathbb{R}\\) varies Periodic (investment) effect \\(\\Phi_k\\) <code>effect--total[effect]</code> \\(\\mathbb{R}\\) varies Total effect over horizon \\(S_f\\) <code>flow--size[flow]</code> \\(\\geq 0\\) MW Invested flow capacity \\(y_f\\) <code>flow--size_indicator[flow]</code> \\(\\{0, 1\\}\\) \u2014 Binary invest indicator (flow) \\(S_s\\) <code>storage--capacity[storage]</code> \\(\\geq 0\\) MWh Invested storage capacity \\(y_s\\) <code>storage--size_indicator[storage]</code> \\(\\{0, 1\\}\\) \u2014 Binary invest indicator (storage) \\(\\sigma_{f,t}\\) <code>flow--on[flow, time]</code> \\(\\{0, 1\\}\\) \u2014 On/off indicator \\(\\tau^+_{f,t}\\) <code>flow--startup[flow, time]</code> \\(\\{0, 1\\}\\) \u2014 Startup event indicator \\(\\tau^-_{f,t}\\) <code>flow--shutdown[flow, time]</code> \\(\\{0, 1\\}\\) \u2014 Shutdown event indicator \\(D^{\\text{up}}_{f,t}\\) <code>uptime[flow, time]</code> \\(\\geq 0\\) h Consecutive uptime \\(D^{\\text{down}}_{f,t}\\) <code>downtime[flow, time]</code> \\(\\geq 0\\) h Consecutive downtime"},{"location":"math/notation/#parameters","title":"Parameters","text":"Symbol Code Domain Unit Description \\(\\bar{P}_f\\) <code>Flow.size</code> \\(\\geq 0\\) or \\(\\infty\\) MW Nominal capacity \\(\\underline{p}_{f,t}\\) <code>Flow.relative_minimum</code> \\([0, 1]\\) \u2014 Relative lower bound \\(\\bar{p}_{f,t}\\) <code>Flow.relative_maximum</code> \\([0, 1]\\) \u2014 Relative upper bound \\(\\pi_{f,t}\\) <code>Flow.fixed_relative_profile</code> \\([0, 1]\\) \u2014 Fixed profile \\(c_{f,k,t}\\) <code>Flow.effects_per_flow_hour</code> \\(\\mathbb{R}\\) varies Effect coefficient per flow-hour \\(\\bar{E}_s\\) <code>Storage.capacity</code> \\(\\geq 0\\) MWh Storage capacity \\(\\eta^{\\text{c}}_s\\) <code>Storage.eta_charge</code> \\((0, 1]\\) \u2014 Charging efficiency \\(\\eta^{\\text{d}}_s\\) <code>Storage.eta_discharge</code> \\((0, 1]\\) \u2014 Discharging efficiency \\(\\delta_s\\) <code>Storage.relative_loss_per_hour</code> \\([0, 1]\\) 1/h Self-discharge rate \\(\\underline{e}_s\\) <code>Storage.relative_minimum_level</code> \\([0, 1]\\) \u2014 Relative min SOC \\(\\bar{e}_s\\) <code>Storage.relative_maximum_level</code> \\([0, 1]\\) \u2014 Relative max SOC \\(a_{f}\\) <code>Converter.conversion_factors</code> \\(\\mathbb{R}\\) \u2014 Conversion coefficient \\(\\alpha_{k,j}\\) <code>Effect.contribution_from</code> \\(\\mathbb{R}\\) varies Cross-effect factor (scalar) \\(\\alpha_{k,j,t}\\) <code>Effect.contribution_from_per_hour</code> \\(\\mathbb{R}\\) varies Cross-effect factor (time-varying) \\(S^-\\) <code>Sizing.min_size</code> \\(\\geq 0\\) MW or MWh Minimum invested size (flow or storage) \\(S^+\\) <code>Sizing.max_size</code> \\(\\geq 0\\) MW or MWh Maximum invested size (flow or storage) \\(\\gamma_{f,k}\\) <code>Sizing.effects_per_size</code> \\(\\mathbb{R}\\) varies Per-size investment cost \\(\\phi_{f,k}\\) <code>Sizing.effects_fixed</code> \\(\\mathbb{R}\\) varies Fixed investment cost \\(D^{\\text{up,min}}\\) <code>Status.min_uptime</code> \\(\\geq 0\\) h Minimum consecutive uptime \\(D^{\\text{up,max}}\\) <code>Status.max_uptime</code> \\(\\geq 0\\) h Maximum consecutive uptime \\(D^{\\text{down,min}}\\) <code>Status.min_downtime</code> \\(\\geq 0\\) h Minimum consecutive downtime \\(D^{\\text{down,max}}\\) <code>Status.max_downtime</code> \\(\\geq 0\\) h Maximum consecutive downtime \\(r_{f,k,t}\\) <code>Status.effects_per_running_hour</code> \\(\\mathbb{R}\\) varies Running cost coefficient \\(u_{f,k,t}\\) <code>Status.effects_per_startup</code> \\(\\mathbb{R}\\) varies Startup cost coefficient \\(w_t\\) weights \\(&gt; 0\\) \u2014 Timestep weight \\(\\Delta t_t\\) dt \\(&gt; 0\\) h Timestep duration"},{"location":"math/notation/#naming-conventions","title":"Naming Conventions","text":"Convention Meaning Example Uppercase Latin Decision variables \\(P\\) (power/flow rate), \\(E\\) (stored energy) Lowercase Latin Relative/dimensionless parameters \\(\\underline{p}\\) (rel. min), \\(\\bar{p}\\) (rel. max) Greek Physical properties \\(\\eta\\) (efficiency), \\(\\delta\\) (loss rate) Overbar / underbar Bounds \\(\\bar{P}\\) (capacity), \\(\\underline{P}\\) (lower bound) Subscripts Indexing \\(f\\) (flow), \\(t\\) (time), \\(s\\) (storage), \\(b\\) (bus), \\(k\\) (effect), \\(j\\) (source effect) Superscripts Qualification \\(\\eta^{\\text{c}}\\) (charge), \\(\\eta^{\\text{d}}\\) (discharge)"},{"location":"math/objective/","title":"Objective Function","text":""},{"location":"math/objective/#formulation","title":"Formulation","text":"<p>The model minimizes the total value of the designated objective effect \\(k^*\\) (the one with <code>is_objective=True</code>):</p> \\[ \\min \\; \\Phi_{k^*} \\] <p>The total effect combines the temporal and periodic domains:</p> \\[ \\Phi_k = \\sum_{t \\in \\mathcal{T}} \\Phi_{k,t}^{\\text{temporal}} \\cdot w_t + \\Phi_k^{\\text{periodic}} \\] <p>The temporal domain accumulates flow contributions, running costs, startup costs, and cross-effect contributions per timestep:</p> \\[ \\Phi_{k,t}^{\\text{temporal}} = \\underbrace{\\sum_{f} c_{f,k,t} \\cdot P_{f,t} \\cdot \\Delta t_t}_{\\text{flow}} + \\underbrace{\\sum_{f} r_{f,k,t} \\cdot \\sigma_{f,t} \\cdot \\Delta t_t}_{\\text{running}} + \\underbrace{\\sum_{f} u_{f,k,t} \\cdot \\tau^+_{f,t}}_{\\text{startup}} + \\underbrace{\\sum_{j} \\alpha_{k,j,t} \\cdot \\Phi_{j,t}^{\\text{temporal}}}_{\\text{cross-effect}} \\] <p>The periodic domain accumulates sizing costs, fixed costs, and cross-effect contributions:</p> \\[ \\Phi_k^{\\text{periodic}} = \\underbrace{\\sum_{f} \\gamma_{f,k} \\cdot S_f + \\sum_{f} \\phi_{f,k} \\cdot y_f + \\sum_{s} \\gamma_{s,k} \\cdot S_s + \\sum_{s} \\phi_{s,k} \\cdot y_s}_{\\text{direct sizing costs}} + \\underbrace{\\sum_{j} \\alpha_{k,j} \\cdot \\Phi_j^{\\text{periodic}}}_{\\text{cross-effect}} \\] <p>See Sizing, Status, and Effects for full formulations of each term.</p>"},{"location":"math/objective/#parameters","title":"Parameters","text":"Symbol Description Reference \\(k^*\\) Objective effect <code>Effect.is_objective = True</code> \\(c_{f,k,t}\\) Effect coefficient per flow-hour <code>Flow.effects_per_flow_hour</code> \\(P_{f,t}\\) Flow rate variable <code>flow--rate[flow, time]</code> \\(\\Delta t_t\\) Timestep duration dt \\(w_t\\) Timestep weight weights \\(\\Phi_{k,t}^{\\text{temporal}}\\) Temporal (per-timestep) effect variable <code>effect--temporal[effect, time]</code> \\(\\Phi_k^{\\text{periodic}}\\) Periodic effect variable (sizing, fixed costs) <code>effect--periodic[effect]</code> \\(\\Phi_k\\) Total effect variable <code>effect--total[effect]</code> <p>See Notation for the full symbol table.</p>"},{"location":"math/objective/#example","title":"Example","text":"<p>Consider a gas boiler over 3 timesteps (\\(\\Delta t = 1\\,\\text{h}\\), \\(w = 1\\)):</p> \\(t\\) \\(P_{\\text{gas},t}\\) (MW) \\(c_{\\text{gas,cost}}\\) (\u20ac/MWh) \\(\\Phi_{\\text{cost},t}^{\\text{temporal}}\\) (\u20ac) 1 2.0 30 \\(30 \\times 2.0 \\times 1 = 60\\) 2 3.0 30 \\(30 \\times 3.0 \\times 1 = 90\\) 3 1.5 30 \\(30 \\times 1.5 \\times 1 = 45\\) <p>Total cost: \\(\\Phi_{\\text{cost}} = \\sum_t \\Phi_{\\text{cost},t}^{\\text{temporal}} = 60 + 90 + 45 = 195\\,\\text{\u20ac}\\)</p> <p>The optimizer finds the \\(P_{f,t}\\) values that minimize \\(\\Phi_{k^*}\\) subject to all constraints (bus balance, flow bounds, conversion, storage dynamics).</p>"},{"location":"math/sizing/","title":"Sizing (Investment Optimization)","text":""},{"location":"math/sizing/#overview","title":"Overview","text":"<p>Sizing introduces a capacity decision variable \\(S\\) that replaces the fixed nominal capacity \\(\\bar{P}_f\\). The solver optimizes both the capacity and the dispatch simultaneously.</p>"},{"location":"math/sizing/#variables","title":"Variables","text":"Symbol Code Domain Description \\(S_f\\) <code>flow_size[flow]</code> \\(\\geq 0\\) Invested flow capacity \\(y_f\\) <code>flow_size_indicator[flow]</code> \\(\\{0, 1\\}\\) Binary: invest yes/no (optional only) \\(S_s\\) <code>storage_capacity[storage]</code> \\(\\geq 0\\) Invested storage capacity \\(y_s\\) <code>storage_size_indicator[storage]</code> \\(\\{0, 1\\}\\) Binary: invest yes/no (optional only)"},{"location":"math/sizing/#mandatory-sizing","title":"Mandatory Sizing","text":"<p>When <code>mandatory=True</code>, the component must be built. The capacity is continuous:</p> \\[ S^- \\leq S_f \\leq S^+ \\quad \\text{(mandatory)} \\] <p>where \\(S^-\\) = <code>min_size</code> and \\(S^+\\) = <code>max_size</code>.</p>"},{"location":"math/sizing/#optional-sizing","title":"Optional Sizing","text":"<p>When <code>mandatory=False</code>, a binary indicator \\(y_f\\) gates the capacity:</p> \\[ S^- \\cdot y_f \\leq S_f \\leq S^+ \\cdot y_f \\] <p>When \\(y_f = 0\\): \\(S_f = 0\\) (not built). When \\(y_f = 1\\): \\(S_f \\in [S^-, S^+]\\).</p>"},{"location":"math/sizing/#binary-invest","title":"Binary Invest","text":"<p>When \\(S^- = S^+\\), the sizing reduces to a binary yes/no decision at exactly that capacity.</p>"},{"location":"math/sizing/#flow-rate-bounds-with-sizing","title":"Flow Rate Bounds with Sizing","text":"<p>With sizing, the fixed capacity \\(\\bar{P}_f\\) is replaced by the variable \\(S_f\\). The relative bounds scale by the invested size:</p> \\[ S_f \\cdot \\underline{p}_{f,t} \\leq P_{f,t} \\leq S_f \\cdot \\bar{p}_{f,t} \\quad \\forall \\, t \\] <p>Similarly for fixed profiles:</p> \\[ P_{f,t} = S_f \\cdot \\pi_{f,t} \\quad \\forall \\, t \\]"},{"location":"math/sizing/#storage-sizing","title":"Storage Sizing","text":"<p>The same pattern applies to storage capacity. The charge state bounds become:</p> \\[ S_s \\cdot \\underline{e}_s \\leq E_{s,t} \\leq S_s \\cdot \\bar{e}_s \\quad \\forall \\, t \\]"},{"location":"math/sizing/#investment-effects","title":"Investment Effects","text":"<p>Investment costs contribute to effect totals. For each effect \\(k\\):</p>"},{"location":"math/sizing/#per-size","title":"Per-Size","text":"\\[ \\Phi_k^{\\text{invest,per\\_size}} = \\sum_{f} \\gamma_{f,k} \\cdot S_f + \\sum_{s} \\gamma_{s,k} \\cdot S_s \\] <p>where \\(\\gamma_{f,k}\\) is <code>Sizing.effects_per_size[k]</code>.</p>"},{"location":"math/sizing/#fixed","title":"Fixed","text":"\\[ \\Phi_k^{\\text{invest,fixed}} = \\sum_{f} \\phi_{f,k} \\cdot y_f + \\sum_{s} \\phi_{s,k} \\cdot y_s \\] <p>where \\(\\phi_{f,k}\\) is <code>Sizing.effects_fixed[k]</code>. Only applies when <code>mandatory=False</code> (binary indicator exists).</p>"},{"location":"math/sizing/#total","title":"Total","text":"<p>The direct investment contribution to effect \\(k\\) is:</p> \\[ \\Phi_k^{\\text{invest}} = \\Phi_k^{\\text{invest,per\\_size}} + \\Phi_k^{\\text{invest,fixed}} \\] <p>This feeds into the effect total equation and can be further weighted by cross-effect contributions.</p>"},{"location":"math/sizing/#parameters","title":"Parameters","text":"Symbol Description Reference \\(S_f\\) Flow capacity variable <code>flow_size[flow]</code> \\(S_s\\) Storage capacity variable <code>storage_capacity[storage]</code> \\(y_f\\), \\(y_s\\) Binary invest indicator <code>flow_size_indicator</code>, <code>storage_size_indicator</code> \\(S^-\\) Minimum size <code>Sizing.min_size</code> \\(S^+\\) Maximum size <code>Sizing.max_size</code> \\(\\gamma_{f,k}\\) Per-size investment cost <code>Sizing.effects_per_size</code> \\(\\phi_{f,k}\\) Fixed investment cost <code>Sizing.effects_fixed</code> <p>See Notation for the full symbol table.</p>"},{"location":"math/status/","title":"Status (On/Off Constraints)","text":""},{"location":"math/status/#overview","title":"Overview","text":"<p>Status adds binary on/off behavior to flows. The core variables are a binary status indicator and transition indicators (startup/shutdown). Duration tracking variables enforce minimum and maximum consecutive up- and downtime.</p>"},{"location":"math/status/#variables","title":"Variables","text":"Symbol Code Domain Description \\(\\sigma_{f,t}\\) <code>flow_on[flow, time]</code> \\(\\{0, 1\\}\\) On/off indicator \\(\\tau^+_{f,t}\\) <code>flow_startup[flow, time]</code> \\(\\{0, 1\\}\\) Startup event indicator \\(\\tau^-_{f,t}\\) <code>flow_shutdown[flow, time]</code> \\(\\{0, 1\\}\\) Shutdown event indicator \\(D^{\\text{up}}_{f,t}\\) <code>uptime[flow, time]</code> \\(\\geq 0\\) Consecutive uptime [h] \\(D^{\\text{down}}_{f,t}\\) <code>downtime[flow, time]</code> \\(\\geq 0\\) Consecutive downtime [h]"},{"location":"math/status/#semi-continuous-flow-rates","title":"Semi-Continuous Flow Rates","text":"<p>With fixed size, the on/off indicator gates the flow rate bounds:</p> \\[ \\bar{P}_f \\cdot \\underline{p}_{f,t} \\cdot \\sigma_{f,t} \\leq P_{f,t} \\leq \\bar{P}_f \\cdot \\bar{p}_{f,t} \\cdot \\sigma_{f,t} \\] <p>When \\(\\sigma_{f,t} = 0\\): \\(P_{f,t} = 0\\). When \\(\\sigma_{f,t} = 1\\): \\(P_{f,t} \\in [\\bar{P}_f \\underline{p}, \\bar{P}_f \\bar{p}]\\).</p> <p>This gives the semi-continuous behavior \\(\\{0\\} \\cup [\\underline{P}, \\bar{P}]\\).</p>"},{"location":"math/status/#switch-transitions","title":"Switch Transitions","text":"<p>Startup and shutdown indicators are linked to status changes:</p> \\[ \\tau^+_{f,t} - \\tau^-_{f,t} = \\sigma_{f,t} - \\sigma_{f,t-1} \\quad \\forall \\, t &gt; 0 \\] <p>At the first timestep with known previous state \\(\\sigma_{f,0}^{\\text{prev}}\\):</p> \\[ \\tau^+_{f,0} - \\tau^-_{f,0} = \\sigma_{f,0} - \\sigma_{f,0}^{\\text{prev}} \\] <p>The previous state is derived from <code>Flow.prior</code>: on if the last prior value &gt; 0, off otherwise. Without <code>prior</code>, the initial transition is unconstrained.</p>"},{"location":"math/status/#duration-tracking","title":"Duration Tracking","text":"<p>Duration tracking uses a Big-M formulation to count consecutive hours in a state.</p>"},{"location":"math/status/#uptime","title":"Uptime","text":"<p>The uptime variable \\(D^{\\text{up}}_{f,t}\\) tracks consecutive on-hours:</p> <p>Reset when off:</p> \\[ D^{\\text{up}}_{f,t} \\leq \\sigma_{f,t} \\cdot M \\quad \\forall \\, t \\] <p>Forward accumulation:</p> \\[ D^{\\text{up}}_{f,t+1} \\leq D^{\\text{up}}_{f,t} + \\Delta t_t \\quad \\forall \\, t \\] <p>Backward tightening (force accumulation when on):</p> \\[ D^{\\text{up}}_{f,t+1} \\geq D^{\\text{up}}_{f,t} + \\Delta t_t + (\\sigma_{f,t+1} - 1) \\cdot M \\quad \\forall \\, t \\] <p>where \\(M\\) is the total horizon length (Big-M constant).</p>"},{"location":"math/status/#downtime","title":"Downtime","text":"<p>Downtime tracking uses the same formulation applied to the inverted state \\((1 - \\sigma_{f,t})\\).</p>"},{"location":"math/status/#minimum-duration","title":"Minimum Duration","text":"<p>Minimum uptime is enforced at shutdown transitions \u2014 the accumulated duration must meet the minimum before turning off:</p> \\[ D^{\\text{up}}_{f,t} \\geq D^{\\text{up,min}} \\cdot (\\sigma_{f,t} - \\sigma_{f,t+1}) \\quad \\forall \\, t &lt; |\\mathcal{T}| \\] <p>The term \\((\\sigma_{f,t} - \\sigma_{f,t+1})\\) equals 1 only at shutdown (on \u2192 off), enforcing \\(D^{\\text{up}}_{f,t} \\geq D^{\\text{up,min}}\\).</p> <p>Minimum downtime follows the same pattern on \\((1 - \\sigma)\\).</p>"},{"location":"math/status/#maximum-duration","title":"Maximum Duration","text":"<p>Maximum duration is enforced as an upper bound on the duration variable itself.</p>"},{"location":"math/status/#previous-duration-carryover","title":"Previous Duration Carryover","text":"<p>When <code>Flow.prior</code> provides historical state, the previous duration is computed by counting consecutive matching timesteps at the end of the prior. At \\(t=0\\):</p> \\[ D^{\\text{up}}_{f,0} = \\sigma_{f,0} \\cdot (D^{\\text{up,prev}} + \\Delta t_0) \\] <p>If the previous uptime hasn't yet met the minimum, the unit is forced to stay on:</p> \\[ \\sigma_{f,0} \\geq 1 \\quad \\text{if } 0 &lt; D^{\\text{up,prev}} &lt; D^{\\text{up,min}} \\]"},{"location":"math/status/#effect-contributions","title":"Effect Contributions","text":""},{"location":"math/status/#running-costs","title":"Running Costs","text":"<p>Running costs are charged per hour of operation, multiplied by the on-indicator:</p> \\[ \\Phi_{k,t}^{\\text{running}} = \\sum_{f} r_{f,k,t} \\cdot \\sigma_{f,t} \\cdot \\Delta t_t \\] <p>where \\(r_{f,k,t}\\) is <code>Status.effects_per_running_hour[k]</code>.</p>"},{"location":"math/status/#startup-costs","title":"Startup Costs","text":"<p>Startup costs are charged per startup event (no duration scaling):</p> \\[ \\Phi_{k,t}^{\\text{startup}} = \\sum_{f} u_{f,k,t} \\cdot \\tau^+_{f,t} \\] <p>where \\(u_{f,k,t}\\) is <code>Status.effects_per_startup[k]</code>.</p> <p>Both feed into the per-timestep effect equation.</p>"},{"location":"math/status/#interaction-with-sizing","title":"Interaction with Sizing","text":"<p>When a flow has both <code>Status</code> and <code>Sizing</code>, the on/off indicator and the size variable are decoupled via Big-M constraints:</p> \\[ P_{f,t} \\leq \\sigma_{f,t} \\cdot M^+ \\qquad \\text{(on-indicator gates flow)} \\] \\[ P_{f,t} \\leq S_f \\cdot \\bar{p}_{f,t} \\qquad \\text{(rate limited by size)} \\] \\[ P_{f,t} \\geq (\\sigma_{f,t} - 1) \\cdot M^- + S_f \\cdot \\underline{p}_{f,t} \\qquad \\text{(minimum when on)} \\] <p>where \\(M^+ = S^+ \\cdot \\bar{p}_{f,t}\\) and \\(M^- = S^+ \\cdot \\underline{p}_{f,t}\\), using the maximum possible size \\(S^+\\) as Big-M.</p> <p>An additional constraint prevents the unit from being \"on\" with zero size:</p> \\[ \\sigma_{f,t} \\leq S_f \\quad \\forall \\, t \\]"},{"location":"math/status/#parameters","title":"Parameters","text":"Symbol Description Reference \\(\\sigma_{f,t}\\) On/off binary <code>flow_on[flow, time]</code> \\(\\tau^+_{f,t}\\) Startup indicator <code>flow_startup[flow, time]</code> \\(\\tau^-_{f,t}\\) Shutdown indicator <code>flow_shutdown[flow, time]</code> \\(D^{\\text{up}}_{f,t}\\) Consecutive uptime <code>uptime[flow, time]</code> \\(D^{\\text{down}}_{f,t}\\) Consecutive downtime <code>downtime[flow, time]</code> \\(D^{\\text{up,min}}\\) Minimum uptime <code>Status.min_uptime</code> \\(D^{\\text{up,max}}\\) Maximum uptime <code>Status.max_uptime</code> \\(D^{\\text{down,min}}\\) Minimum downtime <code>Status.min_downtime</code> \\(D^{\\text{down,max}}\\) Maximum downtime <code>Status.max_downtime</code> \\(r_{f,k,t}\\) Running cost coefficient <code>Status.effects_per_running_hour</code> \\(u_{f,k,t}\\) Startup cost coefficient <code>Status.effects_per_startup</code> \\(M\\) Big-M (horizon length) computed <p>See Notation for the full symbol table.</p>"},{"location":"math/storage/","title":"Storage Dynamics","text":""},{"location":"math/storage/#charge-balance","title":"Charge Balance","text":"<p>The stored energy evolves over time according to charging, discharging, and self-discharge losses:</p> \\[ E_{s,t+1} = E_{s,t} \\left(1 - \\delta_s\\right)^{\\Delta t_t} + P^{\\text{c}}_{s,t} \\, \\eta^{\\text{c}}_s \\, \\Delta t_t - \\frac{P^{\\text{d}}_{s,t}}{\\eta^{\\text{d}}_s} \\, \\Delta t_t \\] <p>where:</p> <ul> <li>\\(E_{s,t}\\) \u2014 stored energy at the start of timestep \\(t\\)</li> <li>\\(P^{\\text{c}}_{s,t}\\) \u2014 charging flow rate (energy entering the storage)</li> <li>\\(P^{\\text{d}}_{s,t}\\) \u2014 discharging flow rate (energy leaving the storage)</li> <li>\\(\\eta^{\\text{c}}_s\\) \u2014 charging efficiency (losses during charging)</li> <li>\\(\\eta^{\\text{d}}_s\\) \u2014 discharging efficiency (losses during discharging)</li> <li>\\(\\delta_s \\in [0, 1]\\) \u2014 self-discharge rate per hour</li> <li>\\(\\Delta t_t\\) \u2014 timestep duration in hours</li> </ul> <p>The charge state has \\(|\\mathcal{T}| + 1\\) values (one before each timestep plus one after the last timestep).</p>"},{"location":"math/storage/#charge-state-bounds","title":"Charge State Bounds","text":"<p>The charge state is bounded by relative SOC limits scaled by the storage capacity:</p> \\[ \\bar{E}_s \\cdot \\underline{e}_s \\leq E_{s,t} \\leq \\bar{E}_s \\cdot \\bar{e}_s \\quad \\forall \\, s, t \\]"},{"location":"math/storage/#initial-cyclic-conditions","title":"Initial &amp; Cyclic Conditions","text":"<p>Fixed initial state:</p> \\[ E_{s,t_0} = E_0 \\] <p>where \\(E_0\\) is <code>Storage.prior_level</code> (absolute MWh). If <code>prior_level</code> is <code>None</code>, the initial level is unconstrained (the optimizer chooses).</p> <p>Cyclic condition (when <code>Storage.cyclic = True</code>):</p> \\[ E_{s,t_{\\text{end}}} = E_{s,t_0} \\] <p>This ensures the storage ends at the same level it started.</p>"},{"location":"math/storage/#parameters","title":"Parameters","text":"Symbol Description Reference \\(E_{s,t}\\) Stored energy variable <code>storage--level[storage, time]</code> \\(P^{\\text{c}}_{s,t}\\) Charging flow rate <code>flow_rate[charge_flow, time]</code> \\(P^{\\text{d}}_{s,t}\\) Discharging flow rate <code>flow_rate[discharge_flow, time]</code> \\(\\bar{E}_s\\) Storage capacity <code>Storage.capacity</code> \\(\\eta^{\\text{c}}_s\\) Charging efficiency <code>Storage.eta_charge</code> \\(\\eta^{\\text{d}}_s\\) Discharging efficiency <code>Storage.eta_discharge</code> \\(\\delta_s\\) Self-discharge rate <code>Storage.relative_loss_per_hour</code> \\(\\underline{e}_s\\) Relative min SOC <code>Storage.relative_minimum_level</code> \\(\\bar{e}_s\\) Relative max SOC <code>Storage.relative_maximum_level</code> \\(\\Delta t_t\\) Timestep duration dt <p>See Notation for the full symbol table.</p>"},{"location":"math/storage/#example","title":"Example","text":"<p>A battery with \\(\\bar{E} = 10\\) MWh, \\(\\eta^{\\text{c}} = 0.95\\), \\(\\eta^{\\text{d}} = 0.95\\), \\(\\delta = 0.001\\)/h, \\(\\Delta t = 1\\) h:</p> <p>Starting at \\(E_0 = 5\\) MWh, charging at \\(P^{\\text{c}} = 2\\) MW:</p> \\[ E_1 = 5 \\times (1 - 0.001)^{1} + 2 \\times 0.95 \\times 1 = 4.995 + 1.9 = 6.895 \\; \\text{MWh} \\]"},{"location":"notebooks/01-quickstart/","title":"Quickstart","text":"In\u00a0[1]: Copied! <pre>from datetime import datetime\n\nimport plotly.express as px\nimport plotly.io as pio\n\nfrom fluxopt import Bus, Converter, Effect, Flow, Port, optimize\n\npio.renderers.default = 'notebook_connected'\n</pre> from datetime import datetime  import plotly.express as px import plotly.io as pio  from fluxopt import Bus, Converter, Effect, Flow, Port, optimize  pio.renderers.default = 'notebook_connected' In\u00a0[2]: Copied! <pre>timesteps = [datetime(2024, 1, 15, h) for h in range(8, 12)]\ntimesteps\n</pre> timesteps = [datetime(2024, 1, 15, h) for h in range(8, 12)] timesteps Out[2]: <pre>[datetime.datetime(2024, 1, 15, 8, 0),\n datetime.datetime(2024, 1, 15, 9, 0),\n datetime.datetime(2024, 1, 15, 10, 0),\n datetime.datetime(2024, 1, 15, 11, 0)]</pre> In\u00a0[3]: Copied! <pre>heat_demand = [30, 50, 45, 25]  # kW per hour\n\npx.bar(x=timesteps, y=heat_demand, labels={'x': 'Time', 'y': 'kW'}, title='Heat Demand')\n</pre> heat_demand = [30, 50, 45, 25]  # kW per hour  px.bar(x=timesteps, y=heat_demand, labels={'x': 'Time', 'y': 'kW'}, title='Heat Demand') In\u00a0[4]: Copied! <pre># Gas supply: up to 1000 kW, costs 0.08 EUR/kWh\ngas_source = Flow(bus='gas', size=1000, effects_per_flow_hour={'cost': 0.08})\n\n# Boiler flows\nfuel = Flow(bus='gas', size=200)\nheat_out = Flow(bus='heat', size=100)\n\n# Heat demand: 50 kW capacity * relative profile = [30, 50, 45, 25] kW\ndemand_flow = Flow(bus='heat', size=50, fixed_relative_profile=[0.6, 1.0, 0.9, 0.5])\n\nresult = optimize(\n    timesteps=timesteps,\n    buses=[Bus('gas'), Bus('heat')],\n    effects=[Effect('cost', unit='EUR', is_objective=True)],\n    ports=[\n        Port('gas_grid', imports=[gas_source]),\n        Port('workshop', exports=[demand_flow]),\n    ],\n    converters=[\n        Converter.boiler('boiler', thermal_efficiency=0.9, fuel_flow=fuel, thermal_flow=heat_out),\n    ],\n)\n</pre> # Gas supply: up to 1000 kW, costs 0.08 EUR/kWh gas_source = Flow(bus='gas', size=1000, effects_per_flow_hour={'cost': 0.08})  # Boiler flows fuel = Flow(bus='gas', size=200) heat_out = Flow(bus='heat', size=100)  # Heat demand: 50 kW capacity * relative profile = [30, 50, 45, 25] kW demand_flow = Flow(bus='heat', size=50, fixed_relative_profile=[0.6, 1.0, 0.9, 0.5])  result = optimize(     timesteps=timesteps,     buses=[Bus('gas'), Bus('heat')],     effects=[Effect('cost', unit='EUR', is_objective=True)],     ports=[         Port('gas_grid', imports=[gas_source]),         Port('workshop', exports=[demand_flow]),     ],     converters=[         Converter.boiler('boiler', thermal_efficiency=0.9, fuel_flow=fuel, thermal_flow=heat_out),     ], ) <pre>Running HiGHS 1.13.1 (git hash: 1d267d9): Copyright (c) 2026 under MIT licence terms\nLP linopy-problem-5zc684_t has 52 rows; 28 cols; 78 nonzeros\nCoefficient ranges:\n  Matrix  [8e-02, 1e+00]\n  Cost    [1e+00, 1e+00]\n  Bound   [0e+00, 0e+00]\n  RHS     [2e+01, 1e+03]\nPresolving model\n0 rows, 0 cols, 0 nonzeros  0s\n0 rows, 0 cols, 0 nonzeros  0s\nPresolve reductions: rows 0(-52); columns 0(-28); nonzeros 0(-78) - Reduced to empty\nPerformed postsolve\nSolving the original LP from the solution after postsolve\n\nModel name          : linopy-problem-5zc684_t\nModel status        : Optimal\nObjective value     :  1.3333333333e+01\nP-D objective error :  1.2841133779e-16\nHiGHS run time      :          0.00\n</pre> In\u00a0[5]: Copied! <pre>total_heat = sum(heat_demand)\ngas_consumed = total_heat / 0.9\n\nprint(f'Total heat demand: {total_heat:.0f} kWh')\nprint(f'Gas consumed:      {gas_consumed:.1f} kWh')\nprint(f'Total cost:        {result.objective:.2f} EUR')\nprint(f'Avg cost of heat:  {result.objective / total_heat:.4f} EUR/kWh')\n</pre> total_heat = sum(heat_demand) gas_consumed = total_heat / 0.9  print(f'Total heat demand: {total_heat:.0f} kWh') print(f'Gas consumed:      {gas_consumed:.1f} kWh') print(f'Total cost:        {result.objective:.2f} EUR') print(f'Avg cost of heat:  {result.objective / total_heat:.4f} EUR/kWh') <pre>Total heat demand: 150 kWh\nGas consumed:      166.7 kWh\nTotal cost:        13.33 EUR\nAvg cost of heat:  0.0889 EUR/kWh\n</pre> In\u00a0[6]: Copied! <pre>df = result.flow_rates.to_dataframe('kW').reset_index()\npx.line(df, x='time', y='kW', color='flow', title='Flow Rates', line_shape='hv')\n</pre> df = result.flow_rates.to_dataframe('kW').reset_index() px.line(df, x='time', y='kW', color='flow', title='Flow Rates', line_shape='hv') <p>Use <code>flow_rate()</code> to get a single flow's time series:</p> In\u00a0[7]: Copied! <pre>df = result.flow_rate('boiler(gas)').to_dataframe('kW').reset_index()\npx.line(df, x='time', y='kW', title='Boiler Gas Consumption', line_shape='hv')\n</pre> df = result.flow_rate('boiler(gas)').to_dataframe('kW').reset_index() px.line(df, x='time', y='kW', title='Boiler Gas Consumption', line_shape='hv') In\u00a0[8]: Copied! <pre>result.effect_totals\n</pre> result.effect_totals Out[8]: <pre>&lt;xarray.DataArray 'effect--total' (effect: 2)&gt; Size: 16B\narray([13.33333333, -0.        ])\nCoordinates:\n  * effect   (effect) &lt;U7 56B 'cost' 'penalty'</pre>xarray.DataArray'effect--total'<ul><li>effect: 2</li></ul><ul><li>13.33 -0.0<pre>array([13.33333333, -0.        ])</pre></li><li>Coordinates: (1)<ul><li>effect(effect)&lt;U7'cost' 'penalty'<pre>array(['cost', 'penalty'], dtype='&lt;U7')</pre></li></ul></li></ul> In\u00a0[9]: Copied! <pre>df = result.effects_temporal.to_dataframe('EUR').reset_index()\npx.bar(df, x='time', y='EUR', color='effect', title='Effects per Timestep')\n</pre> df = result.effects_temporal.to_dataframe('EUR').reset_index() px.bar(df, x='time', y='EUR', color='effect', title='Effects per Timestep')"},{"location":"notebooks/01-quickstart/#quickstart","title":"Quickstart\u00b6","text":"<p>Heat a small workshop with a gas boiler \u2014 the minimal working example.</p> <p>This notebook introduces the core concepts of fluxopt:</p> <ul> <li>Bus: Balance nodes where energy flows meet</li> <li>Flow: Energy transfer on a bus \u2014 with size, bounds, and cost coefficients</li> <li>Effect: Quantities to track and optimize (costs, emissions)</li> <li>Port: Sources and sinks connecting the system to the outside world</li> <li>Converter: Linear coupling between input and output flows</li> </ul>"},{"location":"notebooks/01-quickstart/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/01-quickstart/#define-the-time-horizon","title":"Define the Time Horizon\u00b6","text":"<p>Every optimization needs a time horizon. Here we model a simple 4-hour period:</p>"},{"location":"notebooks/01-quickstart/#define-the-heat-demand","title":"Define the Heat Demand\u00b6","text":"<p>The workshop has varying heat demand throughout the morning:</p>"},{"location":"notebooks/01-quickstart/#build-and-solve-the-energy-system","title":"Build and Solve the Energy System\u00b6","text":"<p>The system has a gas grid, a boiler, and a heat demand:</p> <pre><code>  Gas Grid \u2500\u2500\u25ba [gas bus] \u2500\u2500\u25ba Boiler \u2500\u2500\u25ba [heat bus] \u2500\u2500\u25ba Workshop\n      \u20ac                        \u03b7=90%                    Demand\n</code></pre> <p>In fluxopt, we define Flows (energy on a bus), group them into Ports (sources/sinks) and Converters (coupled flows), then call <code>optimize</code>.</p>"},{"location":"notebooks/01-quickstart/#analyze-results","title":"Analyze Results\u00b6","text":""},{"location":"notebooks/01-quickstart/#total-costs","title":"Total Costs\u00b6","text":"<p>The total cost \u2014 the minimized objective:</p>"},{"location":"notebooks/01-quickstart/#flow-rates","title":"Flow Rates\u00b6","text":"<p>Visualize all flow rates over time. Flow ids are qualified as <code>{component}({bus})</code>.</p>"},{"location":"notebooks/01-quickstart/#effect-totals","title":"Effect Totals\u00b6","text":""},{"location":"notebooks/01-quickstart/#per-timestep-effects","title":"Per-Timestep Effects\u00b6","text":"<p>Cost incurred at each timestep:</p>"},{"location":"notebooks/01-quickstart/#summary","title":"Summary\u00b6","text":"<p>The basic workflow:</p> <ol> <li>Define flows with size, bounds, and cost coefficients</li> <li>Group flows into ports (sources/sinks) and converters</li> <li>Optimize with <code>optimize(timesteps, buses, effects, ports, converters)</code></li> <li>Inspect results via <code>result.flow_rates</code>, <code>result.effect_totals</code>, <code>result.effects_temporal</code></li> </ol>"},{"location":"notebooks/01-quickstart/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>02-heat-system: Add thermal storage to shift loads with time-varying prices</li> </ul>"},{"location":"notebooks/02-heat-system/","title":"Heat System with Storage","text":"In\u00a0[1]: Copied! <pre>import math\nfrom datetime import datetime, timedelta\n\nimport plotly.express as px\nimport plotly.io as pio\n\nfrom fluxopt import Bus, Converter, Effect, Flow, Port, Storage, optimize\n\npio.renderers.default = 'notebook_connected'\n</pre> import math from datetime import datetime, timedelta  import plotly.express as px import plotly.io as pio  from fluxopt import Bus, Converter, Effect, Flow, Port, Storage, optimize  pio.renderers.default = 'notebook_connected' In\u00a0[2]: Copied! <pre>n_hours = 48\ntimesteps = [datetime(2024, 1, 15) + timedelta(hours=h) for h in range(n_hours)]\n\n# Heat demand: sinusoidal pattern - peaks during business hours, low at night\nheat_demand = [50 + 40 * max(0.0, math.sin(math.pi * ((h % 24) - 6) / 12)) for h in range(n_hours)]\n\n# Gas price: off-peak (22:00-06:00) at 0.04 EUR/kWh, peak at 0.08 EUR/kWh\ngas_price = [0.04 if (h % 24) &lt; 6 or (h % 24) &gt;= 22 else 0.08 for h in range(n_hours)]\n</pre> n_hours = 48 timesteps = [datetime(2024, 1, 15) + timedelta(hours=h) for h in range(n_hours)]  # Heat demand: sinusoidal pattern - peaks during business hours, low at night heat_demand = [50 + 40 * max(0.0, math.sin(math.pi * ((h % 24) - 6) / 12)) for h in range(n_hours)]  # Gas price: off-peak (22:00-06:00) at 0.04 EUR/kWh, peak at 0.08 EUR/kWh gas_price = [0.04 if (h % 24) &lt; 6 or (h % 24) &gt;= 22 else 0.08 for h in range(n_hours)] <p>Visualize the demand and price profiles:</p> In\u00a0[3]: Copied! <pre>px.bar(x=timesteps, y=heat_demand, labels={'x': 'Time', 'y': 'kW'}, title='Heat Demand')\n</pre> px.bar(x=timesteps, y=heat_demand, labels={'x': 'Time', 'y': 'kW'}, title='Heat Demand') In\u00a0[4]: Copied! <pre>px.line(x=timesteps, y=gas_price, labels={'x': 'Time', 'y': 'EUR/kWh'}, title='Gas Price')\n</pre> px.line(x=timesteps, y=gas_price, labels={'x': 'Time', 'y': 'EUR/kWh'}, title='Gas Price') In\u00a0[5]: Copied! <pre># Gas supply with time-varying price\ngas_source = Flow(bus='gas', size=500, effects_per_flow_hour={'cost': gas_price})\n\n# Boiler: 150 kW thermal capacity, 92% efficiency\nfuel = Flow(bus='gas', size=300)\nheat_out = Flow(bus='heat', size=150)\n\n# Demand: normalize to relative profile\nmax_demand = max(heat_demand)\ndemand_profile = [d / max_demand for d in heat_demand]\ndemand_flow = Flow(bus='heat', size=max_demand, fixed_relative_profile=demand_profile)\n\n# Thermal storage: 500 kWh, 98% charge/discharge efficiency, 0.5%/h self-discharge\ncharge_flow = Flow(bus='heat', size=100)\ndischarge_flow = Flow(bus='heat', size=100)\nstorage = Storage(\n    'thermal_storage',\n    charging=charge_flow,\n    discharging=discharge_flow,\n    capacity=500,\n    eta_charge=0.98,\n    eta_discharge=0.98,\n    relative_loss_per_hour=0.005,\n    prior_level=250.0,  # start half-full (absolute kWh)\n    cyclic=False,\n)\n\nresult = optimize(\n    timesteps=timesteps,\n    buses=[Bus('gas'), Bus('heat')],\n    effects=[Effect('cost', unit='EUR', is_objective=True)],\n    ports=[\n        Port('gas_grid', imports=[gas_source]),\n        Port('office', exports=[demand_flow]),\n    ],\n    converters=[\n        Converter.boiler('boiler', thermal_efficiency=0.92, fuel_flow=fuel, thermal_flow=heat_out),\n    ],\n    storages=[storage],\n)\n</pre> # Gas supply with time-varying price gas_source = Flow(bus='gas', size=500, effects_per_flow_hour={'cost': gas_price})  # Boiler: 150 kW thermal capacity, 92% efficiency fuel = Flow(bus='gas', size=300) heat_out = Flow(bus='heat', size=150)  # Demand: normalize to relative profile max_demand = max(heat_demand) demand_profile = [d / max_demand for d in heat_demand] demand_flow = Flow(bus='heat', size=max_demand, fixed_relative_profile=demand_profile)  # Thermal storage: 500 kWh, 98% charge/discharge efficiency, 0.5%/h self-discharge charge_flow = Flow(bus='heat', size=100) discharge_flow = Flow(bus='heat', size=100) storage = Storage(     'thermal_storage',     charging=charge_flow,     discharging=discharge_flow,     capacity=500,     eta_charge=0.98,     eta_discharge=0.98,     relative_loss_per_hour=0.005,     prior_level=250.0,  # start half-full (absolute kWh)     cyclic=False, )  result = optimize(     timesteps=timesteps,     buses=[Bus('gas'), Bus('heat')],     effects=[Effect('cost', unit='EUR', is_objective=True)],     ports=[         Port('gas_grid', imports=[gas_source]),         Port('office', exports=[demand_flow]),     ],     converters=[         Converter.boiler('boiler', thermal_efficiency=0.92, fuel_flow=fuel, thermal_flow=heat_out),     ],     storages=[storage], ) <pre>Running HiGHS 1.13.1 (git hash: 1d267d9): Copyright (c) 2026 under MIT licence terms\nLP linopy-problem-9mzh0h_3 has 869 rows; 437 cols; 1399 nonzeros\nCoefficient ranges:\n  Matrix  [4e-02, 1e+00]\n  Cost    [1e+00, 1e+00]\n  Bound   [0e+00, 0e+00]\n  RHS     [5e+01, 5e+02]\nPresolving model\n96 rows, 192 cols, 335 nonzeros  0s\nDependent equations search running on 94 equations with time limit of 1000.00s\nDependent equations search removed 0 rows and 0 nonzeros in 0.00s (limit = 1000.00s)\n94 rows, 190 cols, 331 nonzeros  0s\nPresolve reductions: rows 94(-775); columns 190(-247); nonzeros 331(-1068) \nSolving the presolved LP\nUsing dual simplex solver\n  Iteration        Objective     Infeasibilities num(sum)\n          0     0.0000000000e+00 Pr: 49(3255.17) 0.0s\n        124     1.7717298375e+02 Pr: 0(0) 0.0s\n\nPerformed postsolve\nSolving the original LP from the solution after postsolve\n\nModel name          : linopy-problem-9mzh0h_3\nModel status        : Optimal\nSimplex   iterations: 124\nObjective value     :  1.7717298375e+02\nP-D objective error :  1.5996641037e-16\nHiGHS run time      :          0.00\n</pre> In\u00a0[6]: Copied! <pre>total_heat = sum(heat_demand)\n\nprint(f'Total heat delivered: {total_heat:.0f} kWh')\nprint(f'Total cost:          {result.objective:.2f} EUR')\nprint(f'Avg cost of heat:    {result.objective / total_heat * 100:.2f} ct/kWh')\n</pre> total_heat = sum(heat_demand)  print(f'Total heat delivered: {total_heat:.0f} kWh') print(f'Total cost:          {result.objective:.2f} EUR') print(f'Avg cost of heat:    {result.objective / total_heat * 100:.2f} ct/kWh') <pre>Total heat delivered: 3008 kWh\nTotal cost:          177.17 EUR\nAvg cost of heat:    5.89 ct/kWh\n</pre> In\u00a0[7]: Copied! <pre>df = result.flow_rates.to_dataframe('kW').reset_index()\npx.line(df, x='time', y='kW', color='flow', title='Flow Rates', line_shape='hv')\n</pre> df = result.flow_rates.to_dataframe('kW').reset_index() px.line(df, x='time', y='kW', color='flow', title='Flow Rates', line_shape='hv') In\u00a0[8]: Copied! <pre>storage_flows = [f for f in result.flow_rates.coords['flow'].values if 'thermal_storage' in f]\ndf = result.flow_rates.sel(flow=storage_flows).to_dataframe('kW').reset_index()\npx.line(df, x='time', y='kW', color='flow', title='Storage Charge / Discharge', line_shape='hv')\n</pre> storage_flows = [f for f in result.flow_rates.coords['flow'].values if 'thermal_storage' in f] df = result.flow_rates.sel(flow=storage_flows).to_dataframe('kW').reset_index() px.line(df, x='time', y='kW', color='flow', title='Storage Charge / Discharge', line_shape='hv') In\u00a0[9]: Copied! <pre>df = result.storage_level('thermal_storage').to_dataframe('kWh').reset_index()\npx.area(df, x='time', y='kWh', title='Storage Level', line_shape='hv')\n</pre> df = result.storage_level('thermal_storage').to_dataframe('kWh').reset_index() px.area(df, x='time', y='kWh', title='Storage Level', line_shape='hv') In\u00a0[10]: Copied! <pre>heat_flow_ids = [\n    f for f in result.flow_rates.coords['flow'].values if any(k in f for k in ('heat', 'charge', 'discharge'))\n]\ndf = result.flow_rates.sel(flow=heat_flow_ids).to_dataframe('kW').reset_index()\npx.line(df, x='time', y='kW', color='flow', title='Heat Bus Balance', line_shape='hv')\n</pre> heat_flow_ids = [     f for f in result.flow_rates.coords['flow'].values if any(k in f for k in ('heat', 'charge', 'discharge')) ] df = result.flow_rates.sel(flow=heat_flow_ids).to_dataframe('kW').reset_index() px.line(df, x='time', y='kW', color='flow', title='Heat Bus Balance', line_shape='hv') In\u00a0[11]: Copied! <pre>df = result.effects_temporal.to_dataframe('EUR').reset_index()\npx.bar(df, x='time', y='EUR', color='effect', title='Effects per Timestep')\n</pre> df = result.effects_temporal.to_dataframe('EUR').reset_index() px.bar(df, x='time', y='EUR', color='effect', title='Effects per Timestep')"},{"location":"notebooks/02-heat-system/#heat-system-with-storage","title":"Heat System with Storage\u00b6","text":"<p>District heating with a thermal storage tank and time-varying gas prices.</p> <p>This notebook introduces:</p> <ul> <li>Storage: Thermal buffer with charge/discharge flows, efficiency, and self-discharge</li> <li>Time-varying prices: Cost coefficients that change per timestep</li> <li>Load shifting: The optimizer charges storage when gas is cheap and discharges when expensive</li> </ul>"},{"location":"notebooks/02-heat-system/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/02-heat-system/#generate-time-series-data","title":"Generate Time Series Data\u00b6","text":"<p>We model 48 hours with hourly resolution. Heat demand follows a day/night pattern, and gas prices have off-peak/peak tariffs.</p>"},{"location":"notebooks/02-heat-system/#build-and-solve-the-energy-system","title":"Build and Solve the Energy System\u00b6","text":"<p>The system:</p> <pre><code>Gas Grid \u2500\u2500\u25ba [gas] \u2500\u2500\u25ba Boiler \u2500\u2500\u25ba [heat] \u25c4\u2500\u2500\u25ba Storage\n                         \u03b7=92%       \u2502\n                                     \u25bc\n                                   Office\n</code></pre>"},{"location":"notebooks/02-heat-system/#analyze-results","title":"Analyze Results\u00b6","text":""},{"location":"notebooks/02-heat-system/#cost-summary","title":"Cost Summary\u00b6","text":""},{"location":"notebooks/02-heat-system/#flow-rates","title":"Flow Rates\u00b6","text":"<p>All flow rates across the horizon:</p>"},{"location":"notebooks/02-heat-system/#storage-operation","title":"Storage Operation\u00b6","text":"<p>Charge and discharge rates show the load-shifting behavior:</p>"},{"location":"notebooks/02-heat-system/#storage-level","title":"Storage Level\u00b6","text":"<p>The stored energy over time:</p>"},{"location":"notebooks/02-heat-system/#heat-balance","title":"Heat Balance\u00b6","text":"<p>How boiler output and storage work together to meet demand:</p>"},{"location":"notebooks/02-heat-system/#effect-totals","title":"Effect Totals\u00b6","text":""},{"location":"notebooks/02-heat-system/#key-insights","title":"Key Insights\u00b6","text":"<p>The optimization reveals how storage enables load shifting:</p> <ol> <li>Charge during off-peak: When gas is cheap (night), the boiler runs at higher output to charge the storage</li> <li>Discharge during peak: During expensive periods, storage supplements the boiler, reducing gas purchases</li> <li>Efficiency trade-off: Storage has round-trip losses (0.98 x 0.98 = 96%) plus self-discharge, so shifting only happens when the price spread exceeds the loss cost</li> </ol>"},{"location":"notebooks/02-heat-system/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Add Storage with capacity, efficiency, and self-discharge</li> <li>Use time-varying prices via <code>effects_per_flow_hour</code></li> <li>Inspect storage levels and storage operation</li> <li>Use xarray DataArrays for result analysis</li> </ul>"}]}